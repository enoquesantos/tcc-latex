\section{Projeto da arquitetura}
A arquitetura proposta neste trabalho é baseada em camadas e utiliza os estilos arquiteturais \textit{Client-Server} e \textit{Event-Based}. O modelo em camadas possibilita manter a organização, a separação de conceitos e responsabilidades dos recursos da arquitetura, viabilizando a integração e a comunicação entre os componentes através de conectores que podem ser definidos dinamicamente. No modelo em camadas, a conexão entre os componentes pode ser realizado tanto por eventos como por objetos compartilhados ou, através de leitura e escrita em um arquivo ou em uma base de dados. Porém, nesta arquitetura, foi utilizado somente eventos para comunicação entre componentes. A escolha de eventos como principal conector entre os objetos foi feita principalmente por proporcionar comunicação assíncrona entre emissor e ouvinte e pelo fato de não acoplar os componentes, garantindo maior independência entre os objetos além de permitir que os plugins possam passar dados para outros objetos ou até mesmo outros plugins. Outro motivo da escolha de eventos, é o fato do Qt provê nativamente um mecanismo de comunicação por eventos via sinais e slots.\par


\subsection{Processos de desenvolvimento}
Esta arquitetura foi desenvolvida sob uma metodologia ágil com destaque para uma programação extrema e teste contínuo. A arquitetura recebeu alterações durante 10 meses e a primeira etapa de desenvolvimento introduziu o suporte aos plugins. O primeiro desafio foi desacoplar os plugins do arquivo QRC\footnote{QRC - Qt Resource Collection é um arquivo XML que mapeia os arquivos que serão empacotados no aplicativo} e permitir que a aplicação carregasse-os dinamicamente. Também nesta primeira etapa, foi implementado alguns recursos associados aos plugins, como controle de cache dos arquivos QML, ordenação e \textit{parsing} das páginas (definido pelos plugins), além da criação de um componente genérico a ser extendido por todas as páginas do aplicativo. O controle de cache consiste em regenerar o cache de todos os arquivos da aplicação após uma atualização e se faz necessário para garantir o carregamento de mudanças em cada arquivo a cada release. O componente genérico foi definido como \textit{BasePage.qml} e será detalhado posteriormente, ele foi criado para garantir o atendimento de alguns requisitos mínimos de aparência e estrutura da aplicação além de simplificar a criação de páginas. Na segunda etapa, foi implementado uma classe utilitária para que seus métodos fossem utilizados pelos plugins, oferecendo operações de baixo nível ainda não suportados pelo QML, pois nesta versão da arquitetura, ainda não é suportado a implementação de objetos c++ pelos plugins. Na terceira etapa, foi definido os layouts visuais suportados pela arquitetura e dois modelos foram implementados: O layout em pilha (faz uso do container \textit{StackView}) e o layout em linha (faz uso do container \textit{SwipeView}). O suporte ao layout deve ser definido no arquivo de configuração principal (à ser detalhado posteriormente) nomeado \textit{config.json}. Outros componentes serão instanciados para uso em conjunto com cada layout, dentre eles o \textit{TabBar} e o \textit{ToolBar}. Em etapas seguintes foi desenvolvido componentes visuais reutilizados na aplicação além das APIs para requisição HTTP e persistência de dados via QSLITE.


\subsection{Tecnologias utilizadas}
As tecnologias utilizadas consiste de todos os recursos que foram necessários para o desenvolvimento deste trabalho. O Qt e o \textit{QtCreator} foram os artefatos mais importantes, pois, forneceram os recursos e ferramentas para a construção das principais características da arquitetura. Dentre os recursos providos pelo Qt destaca-se os eventos, que permitem interligar objetos através de sinais e slots\footnote{funções javascript ou métodos de uma classe c++ invocados quando o sinal o qual estão conectados for emitido, recebendo em seus parâmetros os argumentos enviado pelo sinal.} ou \textit{signal handles}, e as APIs providas em classes C++ que integram os recursos da arquitetura, tais como, persistência de dados (via \textit{QSettings} e \textit{QSqlDatabase}) e rede (via \textit{QNetworkAccessManager}). O \textit{QtCreator} é uma IDE que possui recursos integrados à um projeto Qt e foi essencial para o desenvolvimento deste trabalho. Alguns recursos do \textit{QtCreator} destaca-se, facilidade de \textit{build} do projeto, construção do executável do aplicativo e o \textit{deploy} em um \textit{smartphone}, além de facilitar a realização de testes através de um mecanismo integrado de depuração. O \textit{QtCreator} também foi utilizado como editor de código fonte.


% ver link: https://pt.slideshare.net/adrianotavares/modelagem-arquitetural-e-viso-41-presentation %
\subsection{Visão Geral da Arquitetura}
A visão a seguir, apresenta um diagrama de componentes da UML e exibe uma visão lógica dos principais pacotes e arquivos da arquitetura e logo a seguir, é descrito o papel e o conteúdo de cada um deles.

\begin{figure}[h]
	\includegraphics[scale=0.5]{diagrama_geral_da_arquitetura}
	\centering
	\caption{Pacotes principais da arquitetura}
\end{figure}

\begin{description}
	\item[1] \textit{tcc.pro}: Arquivo de configuração de todo projeto Qt. Nele é definido os módulos do Qt a serem utilizados na aplicação, as classes c++ que serão compiladas e linkadas no executável, os aquivos qrc que mapeiam os componentes QML, as imagens e arquivos genéricos a serem empacotados no executável, além de módulos e arquivos de configuração para cada plataforma (linux, osx, android e ios). É neste arquivo que fica definido onde os plugins serão instalados no dispositivo.

	\item[2] \textit{main.cpp}: Arquivo que inicializa a aplicação. Esse arquivo é responsável por instanciar as classes do Qt que exibem a janela do aplicativo e o interpretador de código QML, além de classes da camada de aplicação, configuração e utilitários. O \textit{main.cpp} também é responsável por carregar os arquivos de tradução e registrar objetos no contexto da aplicação a serem utilizados pelos plugins.

	\item[3] \textit{config.json}: Arquivo de configuração principal desta arquitetura, pois define propriedades que indicarão alguns comportamentos iniciais e esolha de tipos de objetos a serem instanciados, tais como exibir os termos de uso na primeira inicialização do aplicativo (carregará o arquivo definido em \textit{assets/eula.html} definido pelo usuário da arquitetura), se tem login ou não (caso sim, instanciará um objeto que gerencia o perfil do usuário e a página de login), se usará layout em linha e etc. Os detalhes deste arquivo será apresentado em um tópico mais adiante.

	\item[4] \textit{src}: Diretório de código fonte. É onde está as classes c++ e componentes QML utilizados internamente e dispostos para plugins como componentes reusáveis. Esse diretório é sub-dividido em outros 5 diretórios que serão detalhados em outro diagrama.

	\item[5] \textit{plugins}: Diretório de plugins. Cada plugin deve obrigatóriamente estar em um sub-diretório com no mínimo um arquivo de configuração de nome \textit{config.json} e os arquivos QML necessirários para o seu funcionamento. Os detalhes das propriedades requeridas para o carregamento de um plugin serão descritas em um tópico posterior.

	\item[6] \textit{translations}: Diretório contendo os arquivos de tradução. Os arquivos de tradução devem ser gerados ou atualizados antes de cada release do aplicativo. Um arquivo de resources \textit{translations.qrc} existe neste diretório e deve ser utilizado para mapear os arquivos de idioma suportados pelo aplicativo. Cada arquivo de tradução deve ser nomeado seguindo o padrão \textit{language\_COUNTRY} com extensão \textit{ts}, por exemplo: \textit{pt\_BR.ts}. Ao iniciar a aplicação, no arquivo \textit{main.cpp}, será identificado o \textit{locale} que define o idioma utilizado no dispositivo e o arquivo correspondente será carregado para que os textos visíveis sejam traduzidos para o usuário. Para gerar as traduções, deve-se utilizar o comando \textit{lupdate *.pro} (na raíz do projeto) para criar ou atualizar o arquivo \textit{ts} principal.

	\item[7] \textit{android}: Diretório contendo os arquivos de configuração do aplicativo para a plataforma android. Outros sub-diretórios guardam arquivos do \textit{gradle} utilizados para o \textit{build} do APK, ícones do lançador do aplicativo e classes java, além de uma versão da lib \textit{openssl} compilada para o funcionamento de requisições HTTP.

	\item[8] \textit{assets}: Diretório contendo imagens e arquivos de configuração do \textit{qtquickcontrols2} além de um arquivo html que pode ser usado para exibir os termos de uso do aplicativo quando utilizado necessário (a propriedade \textit{showEula} seja definido para true no \textit{config.json}). Um arquivo de \textit{resources} \textit{assets.qrc} mapeia todos os arquivos contidos neste diretório e pode ser usado para adicionar outros arquivos a serem empacotados no aplicativo.

	\item[9] \textit{ios}: Diretório contendo os arquivos de configuração do aplicativo para a plataforma ios. Pode conter os ícones do aplicativo, além de imagens diversas requeridas pela plataforma tais como as imagens de \textit{splash-screen}, além do arquivo de configuração \textit{Info.plist} que define nome, versão e recursos do sistema requerido pelo aplicativo.
\end{description}


\subsection{Arquitetura de plugins}
As funcionalidades de um aplicativo baseado nesta arquitetura deve ser implementado pelos plugins, atendendo as necessidades e os requisitos levantados para a aplicação a ser desenvolvida utilizando qml. Os plugins são independentes entre sí e podem incluir arquivos qml, txt, html e imagens em seu diretório. Qualquer componente de um plugin pode reutilizar os componentes públicos usando a diretiva \textit{import "qrc:/src/qml/"}. Os plugins estão desacoplados do núcleo da aplicação e serão conhecidos em tempo de execução. Ao adicionar um novo plugin no diretório \textit{plugins}, ele será carregado no próximo \textit{build} do projeto. Para que um plugin seja reconhecido pelo objeto gerenciador de plugins e carregado pela aplicação, é necessário obedecer a três restrições: estar em um sub-diretório dentro de \textit{plugins}, conter um arquivo \textit{config.json} e pelo menos um arquivo qml visual ou \textit{listener}. Os \textit{listeners} são componentes não visuais que observam eventos da aplicação. O arquivo \textit{config.json} deve ser um objeto contendo as seguintes propriedades:  
\begin{enumerate}
	\item \textit{name} (string): o nome do plugin (opcional);

	\item \textit{description} (string): uma descrição do plugin (opcional);

	\item \textit{pages} (array): uma lista de objetos que indentifica as páginas do plugin a serem exibidas no menu do aplicativo (requerido);

	\item \textit{listeners} (array): uma lista de strings que indentifica os arquivos do plugin (componentes qml não visuais) que serão instanciados como observadores de eventos (opcional).
\end{enumerate}

As páginas indicam objetos visuais que serão instanciadas sob demanda quando o aplicativo tiver utilizando o layout em pilha. No layout em pilha, um menu lateral estará disponível para que o usuário possa navegar nas páginas do aplicativo clicando em um item da lista.\par

Quando o layout em linha estiver sendo utilizado, uma lista horizontal de botões será posicionado no rodapé da janela do aplicativo permitindo ao usuário alternar entre as páginas disponíveis. Porém, no layout em linha, todas as páginas serão instanciadas no início da aplicação e terá um botão associado a cada página, adicionado em um objeto \textit{TabBar}. Cada objeto em \textit{pages} poderá conter as seguintes propriedades que serão lidas pelos componentes que definem os menus durante a inicialização do aplicativo:

\begin{itemize}
	\item \textit{qml} (string): O nome do arquivo correspondente a página. Se esse valor não for definido, a página não será carregada.

	\item \textit{title} (string): O título correspondente a página a ser exibido no menu. Esse valor também é requerido, se não for definido, a página não será carregada.

	\item \textit{icon} (string) (opcional): O nome de um ícone do \textit{Awesome Icons} que será exibido no menu, em conjunto com o título. Se esse valor não for definido, um ícone padrão será utilizado.

	\item \textit{roles} (array): Uma lista de strings contendo os nomes de perfil de usuário que poderão acessar a página. Esse array será útil somente se a aplicação definir o tipo de perfil do usuário no objeto \textit{UserProfile.profile}. Esse valor é opcional, caso não for definido, será setado um array vazio. Porém, se for definido o perfil do usuário no objeto \textit{profile} e essa string não tiver nesta propriedade (\textit{roles}), a página não será exibida.

	\item \textit{order} (integer): Um valor numérico que define a ordem em que a página será exibida na lista de itens nos menus. O desenvolvedor deverá definir um valor acima de zero e quanto maior o valor, maior a prioridade na lista de itens.

	\item \textit{isLoginPage} (boolean): Um valor boleano que indica se a página representa a tela de login do aplicativo e deve ser definido se o valor da propriedade \textit{usesLogin} for definido para true no \textit{config.json} do projeto. Se o aplicativo usa login, o \textit{path} da página definida como login será persistido pois será lido por funções internas do aplicativo na inicialização e quando o usuário fizer \textit{logout}. Se mais de uma página for definida como \textit{loginPage} entre os plugins, será utilizada a última página identificada pelo gerenciador de plugins.

	\item \textit{isHomePage} (boolean): Um valor boleano que indica se a página corresponde a primeira página exibida para o usuário. Se for definido para \textit{true}, o \textit{path} desta página será persisitido e será carregada após o login. No entanto, se o aplicativo não usa login, o aplicativo carregará a página definida como \textit{homePage} na inicialização e será a primeira página exibida para o usuário. Essa propriedade é requerida no modo de layout em pilha e deve ser definida somente pela página correspondente. Se mais de uma página for definida como \textit{homePage}, será utilizada a última página identificada pelo gerenciador de plugins.

	\item \textit{showInDrawer} (boolean): Um valor boleano que indica se a página poderá ser exibida no menu de layout em pilha. O menu de layout em pilha será instanciado por padrão no layout em pilha, porém, também pode ser instanciado no layout em linha, basta definir a propriedade \textit{usesDrawer} para \textit{true} no arquivo de configuração. O layout em linha utiliza uma barra de botões como menu e com isso, é possível permitir acesso a páginas diferentes a partir dos dois menus.

	\item \textit{showInTabBar} (boolean): Um valor boleano que indica se a página poderá ser exibida no menu de layout em linha. O objetivo desse flag é permitir exibir páginas diferentes nos menus quando o \textit{Drawer} menu estiver sendo utilizado, permitindo assim, exibir páginas diferentes nos dois menus.
\end{itemize}

No layout em pilha, o menu é exibido pelo componente \textit{Menu.qml} que consiste de uma instância do objeto \textit{Drawer} do \textit{QuickControls} e as páginas serão listadas verticalmente. A figura a seguir apresenta um exemplo deste menu com uma lista simples de páginas.


No layout em linha, o menu corresponde ao componente \textit{TabBar.qml} também do \textit{QuickControls} com algumas modificações. É importante destacar que os plugins serão carregados e persistidos na primeira inicialização em um array de objetos. No entanto, esse array será reconstruído quando a aplicação estiver sendo executada em modo \textit{debug} ou desktop, para que novos plugins sejam carregadas sem necessitar a limpeza do cache do aplicativo durante o desenvolvimento. Em modo \textit{release}, por questões de desempenho, o aplicativo carregará as plugins a partir da persistência local do aplicativo. Os plugins serão lidos a cada release após atualização da versão do aplicativo.\par


%adicionar um diagrama de componentes mostrando os plugins em um diretório de plugins e outros diretórios da aplicação
\subsubsection{Gerenciamento de plugins}\label{sec:solucao-desenvolvida}
A classe \textit{PluginManager} é responsável por carregar os plugins, percorrendo todos os arquivos dentro do diretório \textit{plugins} e analizando as propriedades definida no arquivo \textit{config.json} de cada plugin. Em cada arquivo, é verificado as propriedades definida para cada página adicionando-a como objeto em um array. Após ler todos os plugins, o array de objetos é persistido nas configurações da aplicação para que na próxima inicialização não precise iterar novamente o diretório, lendo as definições dos plugins das configurações, exceto se houver uma atualização da aplicação ou quando a aplicação é executada em modo \textit{debug}. A cada inicialização, é feito uma verificação da versão do aplicativo, que também é persistida nas configurações, se houver diferença entre versão em execução da versão salva na execução anterior (se existir), os plugins serão recarregados. Além disso, esta classe também é reponsável por deletar todos os arquivos de cache contido no diretório de cache da aplicação a cada release. Outra responsabilidade dessa classe, é a criação da tabela de banco de dados do plugin se o plugin dispor de um arquivo \textit{plugin\_table.sql} em seu diretório. O banco de dados da aplicação é criado por um objeto que gerencia as operações de persistência e será detalhado em outro tópico. O diagrama a seguir, apresenta as operações e atributos da classe \textit{PluginManager}.

\begin{figure}[h]
	\includegraphics[width=8cm]{diagrama_de_classe_PluginManager}
	\centering
	\caption{Diagrama da classe PluginManager}
\end{figure}

O objeto \textit{app} é responsável por instanciar \textit{PluginManager} na inicialização do aplicativo, este objeto é uma instância da classe \textit{App} que será apresentada no próximo tópico. O processo de carregamento dos plugins é feito antes de instanciar qualquer componente visual, na invocação do método \textit{loadPlugins}. O objeto \textit{pluginManager} será destruido após o carregamento dos plugins para manter baixo consumo de memória pelo aplicativo.


\subsection{A classe App}\label{sec:solucao-desenvolvida}
A classe \textit{App} é um componente importante nesta arquitetura, suas responsabilidades consiste de instanciar \textit{PluginManager} que carregará os plugins, carregar o arquivo \textit{config.json} principal que contém os parâmetros da aplicação e gerenciar a persistência das configurações da aplicação via \textit{QSettings}\footnote{Uma classe do Qt que abstrai a plataforma e fornece um mecanismo de leitura e escrita de dados no dispositivo através de métodos parametrizados}. A classe \textit{App} é instanciada no \textit{main.cpp} e é registrada no contexto da aplicação para que os plugins e componentes qml possam invocar seus métodos públicos definidos como \textit{Q\_INVOKABLE}, como por exemplo, o método \textit{readSettings} que retorna um tipo genérico de dado, lido das configurações do aplicativo usando algum parâmetro que identifique o dado a ser lido. Outra tarefa que app faz é carregar o arquivo \textit{config.json} do projeto, que contém propriedades requeridas pela aplicação. Esse arquivo também é registrado no contexto da aplicação como um objeto javascript nomeado \textit{Config} em modo leitura, pois não pode receber alterações e nem será persistido, logo é carregado toda vez que a aplicação é inicializada.


O objeto app é também o responsável por instanciar a classe \textit{PluginManager}, que realiza o trabalho de carregar os plugins do aplicativo. Outra responsabilidade deste objeto, é a notificação de eventos vindos do objeto \textit{QtActivity} no android e \textit{QtAppDelegate} no iOS como o \textit{token} de registro no \textit{Firebase}\footnote{O Firebase antigo \textit{Google Cloud Messaging} é um serviço de notificação móvel desenvolvido pelo Google que permite que os desenvolvedores de aplicativos enviem dados ou informações de notificação de servidores executados pelo desenvolvedor para aplicativos Android e iOS.} e mensagens de \textit{push notification} que em ambos os eventos, são delegados para o aplicativo através de uma conexão com um \textit{slot} definido no \textit{Application Window}.

\begin{figure}[h]
	\includegraphics[width=8cm]{a_classe_app}
	\centering
	\caption{Os objetos compostos da classe App}
\end{figure}

O Objeto App também fornece métodos públicos declarados como 


\subsection{O arquivo config.json}\label{sec:solucao-desenvolvida}
O arquivo \textit{Settings.json} é um arquivo importante e requerido nesta arquitetura. As propriedades presentes neste arquivo não são persistidas no banco de dados e serão setadas em um objeto do tipo \textit{QVariantMap} na classe App, sempre que o aplicativo for executado. Este objeto será registrado no contexto da aplicação como uma propriedade e será utilizado por vários componentes, tais como, elementos visuais que definem cores, font-size e outras propriedades que podem ser definidas neste json e poderão ser acessadas por qualquer plugin. Algumas propriedades como versão do aplicativo e se está ou não em modo de depuração. O número da versão é especificado na chave \textit{version} e é utilizado pelo objeto ManagerPlugins que decidirá se o cache dos arquivos QML serão deletados para que os arquivos QML presentes na nova versão sejam regenerados. será utilizado por mapear tanto o tema de cores utilizado pelos componentes visuais como também detalhes de nome, versão e descrição do aplicativo.


\subsection{Comunicação entre os objetos}
Esta seção descreve o processo de comunicação entre objetos ou componentes dentro do aplicativo...


\subsection{Comunicação com serviço REST}
Esta seção descreve o processo de comunicação entre objetos ou componentes dentro do aplicativo...


\subsection{Gerencimento de Rede (HTTP)}\label{sec:solucao-desenvolvida}
\subsubsection{O Componente RequestHttp}\label{sec:solucao-desenvolvida}
O Objeto RequestHttp....


\subsection{Gerencimento de Banco de Dados}\label{sec:solucao-desenvolvida}
\subsubsection{A classe Database}\label{sec:solucao-desenvolvida}
\subsubsection{O Componente DatabaseComponent}\label{sec:solucao-desenvolvida}
O Objeto ModelData....


\subsection{Componentes Visuais}\label{sec:solucao-desenvolvida}
O Objeto ModelData....


\subsection{O Componente Basepage}\label{sec:solucao-desenvolvida}
O Objeto ModelData....


\subsection{Fluxo de execução}\label{sec:solucao-desenvolvida}
%Adicionar um diagrama de sequência que mostre a inicialização, carregamento dos plugins e configuração geral do aplicativo%


\subsection{Métodos para utilização da arquitetura}
-- descrever o README do projeto no github

OU:
Exemplo (a ser editado): Para se utilizar a arquitetura desenvolvida, deve-se seguir uma determinada ordem de atividades (Figura 26), que deve se iniciar no nível arquitetural “escopo” (seção 3.1), passando pelos níveis arquiteturais “modelo de negócios” (seção 3.2) e “modelo de sistema” (seção 3.3), até chegar ao nível arquitetural “modelo tecnológico” que deve ser criado pelo usuário desta arquitetura.