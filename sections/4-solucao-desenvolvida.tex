\section{Projeto da Arquitetura}
A arquitetura proposta neste trabalho utiliza os estilos arquiteturais \textit{Client-Server} e \textit{Event-Based} \cite{medvidovic}. \textit{Client-Server} pelo fato de permitir ao aplicativo consumir algum serviço \textit{RESTful} através de uma API de alto nível para acesso a rede, tonando o aplicativo um cliente, enquanto que o serviço \textit{RESTful} representa o servidor. Já o \textit{Event-Based} é estilo de arquitetural que caracteriza a comunicação entre objetos através de eventos \cite{medvidovic}, que neste trabalho, é um recurso disposto através de componentes reusáveis. A arquitetura dispõe de objetos de baixo nível escritos em C++ que trabalham na camada de aplicação, recebendo dados de objetos da camada \textit{UI} e interagem com objetos da camada de \textit{middleware} que realizam a comunicação com o serviço \textit{RESTful} configurado para o aplicativo, caracterizando a arquitetura como um modelo em camadas. No modelo em camadas, a conexão entre os componentes pode ser realizado tanto por eventos como por objetos compartilhados ou, através de leitura e escrita em um arquivo ou em uma base de dados. Porém, nesta arquitetura, foi utilizado somente eventos para comunicação entre os objetos. A escolha de eventos como principal conector entre os objetos foi feita principalmente por proporcionar comunicação assíncrona entre emissor e ouvinte e pelo fato de não acoplar os componentes, garantindo maior independência entre eles. Outro motivo da escolha de eventos, é o fato do Qt prover nativamente um mecanismo de comunicação através de eventos.\par


\subsection{Tecnologias Utilizadas}
As tecnologias utilizadas consiste de todos os elementos utilizados durante o desenvolvimento deste trabalho. O Qt e o \textit{QtCreator} foram os elementos mais importantes, pois, forneceram os recursos e ferramentas para a construção das principais características da arquitetura. Dentre os recursos providos pelo Qt destaca-se os eventos, que permitem interligar objetos através de sinais e slots\footnote{funções javascript ou métodos de uma classe c++ invocados quando o sinal o qual estão conectados for emitido, recebendo em seus parâmetros os argumentos enviado pelo sinal.} ou \textit{signal handles}, e as APIs providas em classes C++ que integram os recursos da arquitetura, tais como, persistência de dados (via \textit{QSettings} e \textit{QSqlDatabase}) e rede (via \textit{QNetworkAccessManager}). O \textit{QtCreator} é uma IDE que possui recursos integrados à um projeto Qt com destaque para facilidade de \textit{build} do projeto, construção do executável do aplicativo e o \textit{deploy} em um \textit{smartphone}. O \textit{QtCreator} também foi utilizado como editor de código fonte.


\subsection{Processo de Projeto Arquitetural}
Esta arquitetura foi desenvolvida durante 10 meses e a primeira etapa de desenvolvimento introduziu o suporte aos plugins. O primeiro desafio foi desacoplar os plugins do arquivo \textit{qrc}\footnote{qrc – \textit{Qt resource collection} é um arquivo xml que mapeia os arquivos que serão empacotados no aplicativo.} e permitir que a aplicação carregasse-os dinamicamente. Também nesta primeira etapa, foi implementado alguns recursos associados aos plugins, como controle de cache dos arquivos QML, ordenação e \textit{parsing} das páginas (definido pelos plugins), além da criação de um componente genérico a ser estendido por todas as páginas do aplicativo. O controle de cache consiste em regenerar o cache dos arquivos QML após uma atualização para garantir o carregamento de mudanças em cada arquivo a cada \textit{release}. O componente genérico foi definido como \textit{BasePage.qml}, ele é um objeto da camada \textit{UI} e foi criado para garantir o atendimento de alguns requisitos mínimos de aparência, estrutura e simplificar a criação de páginas. Na segunda etapa, foi implementado classes C++ para gerenciar as configurações da aplicação, uma classe utilitária com métodos a serem invocados pelos plugins para operações de baixo nível que ainda não são suportados pelo QML.\par

Na terceira etapa, foi definido os layouts visuais suportados pela arquitetura e dois modelos foram implementados: O layout em pilha, que faz uso do \textit{container} \textit{StackView} e o layout em linha, que faz uso do \textit{container} \textit{SwipeView}, ambos do \textit{Quick Controls}\footnote{módulo do Qt que provê um conjunto de componentes QML para construção de interfaces gráficas.}. Em etapas seguintes, foram desenvolvidas as APIs para acesso a rede, notificações do aplicativo e persistência de dados e os componentes visuais reutilizáveis. Os \textit{containers} de layout trabalham na camada \textit{UI} e gerenciam a criação e remoção das páginas do aplicativo. É importante destacar que em ambos os layouts, somente uma página pode ser visualizada por vez. As Figuras a seguir apresentam os layouts em pilha e em linha.

\begin{figure}[H]
	\includegraphics[scale=0.5]{stackview_wireframe}
	\centering
	\caption{Estrutura de um layout em pilha}
\end{figure}

No layout em pilha, o componente \textit{ToolBar.qml} será instanciado e posicionado no topo da janela do aplicativo e trabalhará em conjunto com o \textit{StackView}. O \textit{ToolBar} fará \textit{bindings} com algumas propriedades da página ativa, como por exemplo, adicionando ou removendo botões com ações para a página atual.

\begin{figure}[H]
	\includegraphics[scale=0.5]{swipeview_wireframe}
	\centering
	\caption{Estrutura de um layout em linha}
\end{figure}

No layout em linha, o componente \textit{TabBar.qml} será instanciado e posicionado no rodapé da janela do aplicativo. O TabBar corresponde ao menu no layout em linha e trabalhará em conjunto com o \textit{SwipeView}. A arquitetura suporta intercalar os dois layouts ao mesmo tempo e um objeto \textit{Binding} do QML manterá o \textit{SwipeView} visível somente quando não houver páginas na pilha do \textit{StackView}. No entanto, o \textit{SwipeView} será instanciado somente se a propriedade \textit{usesSwipeView} for definida para \textit{true} no arquivo de configuração e se tornará o \textit{container} principal. Os objetos correspondentes aos layouts serão instanciados na inicialização e os plugins poderão adicionar ou remover páginas dinamicamente utilizando os objetos \textit{swipeView} e \textit{pageStack} quando for necessário navegar para uma determinada página a partir de outra, sem ser pelo menu.\par


\subsection{Requisitos Funcionais Suportados}
O projeto desta arquitetura visa atender quatro requisitos funcionais entendidos como básicos em todo sistema de informação. Para atender aos requisitos, foi implementado APIs usando classes C++ nativas do Qt. Apesar de o QML dispôr de funcionalidades que poderiam atender a estes requisitos, foi decidido implementar em C++ por questões de desempenho devido menos código interpretado, melhor gerenciamento de memória e para simplificar a implementação de código nos plugins. Os requisitos listados a seguir, foram disponibilizados na arquitetura através de APIs de alto nível que serão apresentadas em tópicos específicos posteriormente, estes quatro requisitos são:

\begin{enumerate}
	\item Acesso a rede para comunicação com serviços \textit{RESTful};
	\item Persistência de dados local via \textit{SQLITE};
	\item Notificações do aplicativo via \textit{push} e local;
	\item Comunicação entre objetos facilitado.
\end{enumerate}


\subsection{Visão Estrutural}
A Figura 3, apresenta um diagrama de pacotes e arquivos destacando uma visão lógica dos principais elementos da arquitetura. Em seguida, será descrito a responsabilidade e o conteúdo de cada um deles.

\begin{figure}[H]
	\includegraphics[width=8cm]{diagrama_geral_da_arquitetura_atualizado2}
	\centering
	\caption{Pacotes principais da arquitetura}
\end{figure}

\begin{description}
	\item[1] \textit{main.cpp}: Arquivo inicialização da aplicação Qt. Esse arquivo é responsável por instanciar as classes do Qt que exibem a janela do aplicativo e gerenciam o \textit{loop} da aplicação, além do interpretador QML e classes da camada de aplicação. O \textit{main.cpp} também é responsável por carregar o arquivo de tradução de acordo com o idioma do dispositivo e registrar objetos no contexto da aplicação a serem utilizados pelos plugins.

	\item[2] \textit{tcc.pro}: Arquivo de configuração de todo projeto Qt. Nele é definido os módulos do Qt a serem utilizados na aplicação, as classes C++ que serão compiladas e adicionadas no executável, os aquivos \textit{qrc} que mapeiam os componentes QML, as imagens e arquivos genéricos a serem empacotados no aplicativo, além de módulos e arquivos de configuração para cada plataforma (linux, osx, android e iOS). É neste arquivo que fica definido onde os plugins serão instalados no dispositivo.

	\item[3] \textit{config.json}: Arquivo de configuração do aplicativo que deve ser editado pelo desenvolvedor. Ele contém propriedades que indicarão alguns comportamentos iniciais, além do tipo de layout a ser utilizado no aplicativo. Outra propriedade presente nesse arquivo, é a opção de exibir ou não os termos de uso na primeira inicialização (carregará o arquivo \textit{assets/eula.html} definido pelo desenvolvedor), se tem login ou não (caso sim, instanciará um objeto que gerencia o perfil do usuário e exibirá a página de login na inicialização) entre outras propriedades. Os detalhes deste arquivo serão apresentados em um tópico mais adiante.

	\item[4] \textit{src}: Diretório de código fonte. É onde estão as classes C++, componentes QML utilizados internamente e dispostos para os plugins como reusáveis. Esse diretório está sub-dividido em outros seis diretórios que organizam as classes por tipo de API e são eles:

	\begin{itemize}
		\item \textit{core}: contém classes do núcleo da aplicação dentre elas \textit{Settings}, \textit{PluginManager}, \textit{Observer}, \textit{Subject} e \textit{Utils};

		\item \textit{database}: contém classes da API de persistência de dados;

		\item \textit{extras}: contém classes de customização de estilo no android;

		\item \textit{notification}: contém as classes que gerenciam as notificações baseadas na plataforma;

		\item \textit{network}: contém as classes da API de rede (HTTP);

		\item \textit{qml}: contém os arquivos QML sub-divididos em \textit{private} e \textit{public}, sendo os componentes em \textit{private} os que são utilizados internamente pela aplicação e os que estão em \textit{public} os reutilizáveis.
	\end{itemize}

	\item[5] \textit{plugins}: Diretório de plugins. Cada plugin deve estar em um sub-diretório com no mínimo um arquivo de configuração de nome \textit{config.json} e os arquivos QML necessários para o seu funcionamento. Os detalhes dos requisitos para o carregamento de um plugin serão descrito em um tópico posterior.

	\item[6] \textit{translations}: Diretório contendo os arquivos de tradução. Os arquivos de tradução devem ser gerados ou atualizados antes de cada \textit{release} do aplicativo. Um arquivo de resources \textit{translations.qrc} existe neste diretório e deve ser utilizado para mapear os arquivos de idioma suportados pelo aplicativo. Cada arquivo de tradução deve ser nomeado seguindo o padrão \textit{language\_COUNTRY} com extensão \textit{ts}, por exemplo: \textit{pt\_BR.ts}. Ao iniciar a aplicação, o \textit{main}, tentará identificar o idioma do dispositivo e o arquivo de tradução correspondente (se houver) será carregado para que os textos visíveis sejam traduzidos para o usuário. Para gerar as traduções, deve-se utilizar o comando \textit{lupdate -recursive . -ts translations/pt\_BR.ts} (na raíz do projeto) para criar ou atualizar o arquivo \textit{ts} do idioma especificado.

	\item[7] \textit{android}: Diretório contendo os arquivos de configuração do aplicativo para a plataforma android. Outros sub-diretórios guardam arquivos do \textit{gradle} utilizados para o \textit{build} do APK, ícones do lançador do aplicativo e classes java, além de uma versão da lib \textit{openssl} compilada para o funcionamento de requisições HTTP.

	\item[8] \textit{assets}: Diretório contendo imagens e arquivos de configuração do \textit{qtquickcontrols2}, além de um arquivo html que pode ser usado para exibir os termos de uso do aplicativo quando necessário (se a propriedade \textit{showEula} for definida para \textit{true} no arquivo de configuração). Um arquivo de \textit{resources} \textit{assets.qrc} mapeia todos os arquivos contidos neste diretório.

	\item[9] \textit{ios}: Diretório contendo os arquivos de configuração do aplicativo para a plataforma iOS. Pode conter os ícones e imagens requeridas pelo iOS, tais como as imagens de \textit{splash-screen}, além do arquivo de configuração \textit{Info.plist} que define nome, versão do aplicativo e os recursos do sistema requerido para o funcionamento da aplicação no iOS (permissão para acessar a câmera do dispositivo, enviar mensagens via \textit{push} etc.).
\end{description}


\subsection{Infraestrutura de Plugins}
As funcionalidades de um aplicativo baseado nesta arquitetura devem ser implementadas através de plugins, atendendo aos requisitos do aplicativo a ser desenvolvido utilizando apenas QML. Os plugins são independentes entre sí e podem incluir arquivos QML, TXT, HTML e imagens em seu diretório. Qualquer componente de um plugin pode reutilizar os componentes públicos usando a diretiva \textit{import "qrc:/publicComponents/"}. Ao todo, dez componentes foram disponibilizados e serão apresentados em uma seção posterior.\par

Os plugins estão desacoplados do núcleo da aplicação e serão conhecidos em tempo de execução. Ao adicionar um novo plugin no diretório \textit{plugins}, ele será carregado no próximo \textit{build}. Para que um plugin seja identificado pelo objeto gerenciador de plugins e carregado na aplicação, é necessário obedecer as seguintes restrições:

\begin{enumerate}
	\item[1ª] estar em um sub-diretório dentro de \textit{plugins};
	\item[2ª] conter um arquivo \textit{config.json} neste sub-diretório;
	\item[3ª] conter pelo menos um arquivo QML.
\end{enumerate}

O arquivo \textit{config.json} de um plugin deve ser um objeto json contendo as seguintes propriedades:

\begin{enumerate}
	\item \textit{listeners} (array): uma lista de strings que identifica os arquivos do plugin (componentes QML não visuais) que serão instanciados como observadores de eventos da aplicação. O preenchimento dessa propriedade é opcional e pode ser preenchida mesmo que a propriedade \textit{pages} seja definida. Os itens especificados em \textit{listeners} serão instanciados dinamicamente na inicialização do aplicativo e poderão ser destruídos quando não forem mais necessários, invocando o método \textit{destroy} a partir do elemento raiz do objeto.

	\item \textit{pages} (array): uma lista de objetos que identifica as páginas do plugin que serão acessadas a partir dos menus do aplicativo e deve ser preenchido se a propriedade \textit{listeners} estiver vazia.
\end{enumerate}

Cada objeto em \textit{pages} poderá conter as seguintes propriedades:

\begin{itemize}
	\item \textit{qml} (string): O nome do arquivo correspondente a página. Se essa propriedade não for definida, a página não será carregada;

	\item \textit{title} (string): O título correspondente a página a ser exibido no menu. Esse valor também é requerido, se não for definido, a página não será adicionada ao menu;

	\item \textit{awesomeIcon} (string) (opcional): O nome de um ícone do \textit{Awesome Icons}\footnote{https://fontawesome.com/icons} que será exibido no menu, em conjunto com o título. Se esse valor não for definido, um ícone padrão (\textit{gear}) será utilizado;

	\item \textit{roles} (array): Uma lista de strings contendo os nomes de perfil de usuário que poderão acessar a página. Essa lista será útil somente se for definido o tipo de perfil do usuário no objeto \textit{userProfile.profile}. O objeto \textit{userProfile} é \textit{null} por padrão e será instanciado na inicialização do aplicativo se a propriedade \textit{usesLogin} for definida para \textit{true} no arquivo de configuração. Caso \textit{roles} não for definido, será setado um array vazio. Porém, se \textit{userProfile} for instanciado, ou seja, tiver login na aplicação e for definido uma string contendo o tipo de perfil do usuário e, essa string não tiver em \textit{roles}, a página não será exibida para o usuário. Informações sobre o objeto \textit{userProfile} será detalhado em um tópico posterior;

	\item \textit{order} (int): Um valor numérico que define a ordem em que a página será exibida na lista de itens nos menus. O desenvolvedor deverá definir um valor acima de zero e quanto maior o valor, maior a prioridade da página na lista de itens dos menus;

	\item \textit{isLoginPage} (bool): Um valor booleano que indica se a página representa a tela de login do aplicativo e deve ser definido pela página correspondente se a propriedade \textit{usesLogin} for definido para \textit{true} no arquivo de configuração. Se o aplicativo usa login, o \textit{path} da página definida como login será persistido pois, será lido por funções internas do aplicativo na inicialização e quando o usuário fizer \textit{logout}. Se mais de uma página definir \textit{isLoginPage} para \textit{true} dentre os plugins, será utilizada a última página identificada pelo gerenciador de plugins;

	\item \textit{isHomePage} (bool): Um valor booleano que indica se a página corresponde a primeira página exibida para o usuário e deve ser utilizado pela página correspondente quando o layout em pilha estiver sendo utilizado. O \textit{path} dessa página será persistido durante o carregamento dos plugins e será carregada por funções internas na inicialização quando não houver login ou, após o usuário efetuar o login e o json do usuário for passado em um evento específico que inicializa o perfil do usuário (esse recurso será detalhado posteriormente). Se mais de uma página definir \textit{isHomePage} para \textit{true}, será utilizada a última página identificada pelo gerenciador de plugins;

	\item \textit{showInDrawer} (bool): Um valor booleano que indica se a página poderá ser exibida no menu de layout em pilha. Por padrão, o menu de layout em pilha será carregado quando \textit{StackView} for utilizado. Porém, poderá ser instanciado no layout em linha se a propriedade \textit{usesDrawer} for definida para \textit{true} no arquivo de configuração. O layout em linha utiliza uma barra de botões como menu e através dessa propriedade, possibilita ao usuário acessar páginas diferentes a partir dos dois menus do aplicativo;

	\item \textit{showInTabBar} (bool): Um valor booleano que indica se a página poderá ser exibida no menu de layout em linha. O objetivo dessa propriedade é permitir exibir páginas diferentes nos menus quando o \textit{drawer menu} for instanciado.
\end{itemize}

O Exemplo 1, apresenta um código json de um plugin contendo uma lista de páginas. Após o carregamento do plugin, as páginas serão exibidas no menu do aplicativo e podem ser visualizadas nas Figuras 4 e 5.
\begin{center}
\begin{lstlisting}[language=json,caption={JSON de configuração de um plugin},captionpos=b]
{
	pages:[
		{
			qml:"Page1.qml",
			title:"Pagina 1",
			awesomeIcon:"commenting",
			order:3,
			roles:["student"],
			showInDrawer:true,
			showInTabBar:true
		},
		{
			qml:"Page2.qml",
			title:"Pagina 2",
			awesomeIcon:"calendar",
			order:4,
			roles:["student","teacher"],
			showInDrawer:true,
			showInTabBar:true
		},
		{
			qml:"Page3.qml",
			title:"Pagina 3",
			awesomeIcon:"code_fork",
			order:5,
			roles:["student","teacher"],
			showInDrawer:true,
			showInTabBar:true
		}
		...
	]
}
\end{lstlisting}
\end{center}

As páginas serão instanciadas sob demanda quando o aplicativo estiver utilizando o layout em pilha, que ocorrerá quando o usuário clicar em um item da lista. No layout em pilha, o menu é exibido pelo componente \textit{Drawer.qml} que consiste de uma instância do objeto \textit{Drawer} do \textit{Quick Controls} e as páginas serão listadas verticalmente (Figura 4).\par

Quando o layout em linha estiver sendo utilizado, uma lista horizontal de botões será adicionado no rodapé da janela do aplicativo permitindo ao usuário alternar entre as páginas disponíveis. Porém, no layout em linha, todas as páginas serão instanciadas no início da aplicação e terá um botão associado a cada página. No layout em linha, o menu corresponde ao componente \textit{TabBar.qml} que consiste de uma instância do objeto \textit{TabBar} do \textit{Quick Controls} com algumas modificações (Figura 5). As Figuras a seguir, apresentam exemplos dos layouts em pilha e em linha.

\begin{figure}[H]
	\includegraphics[width=8cm]{exemplo_menu_layout_em_pilha}
	\centering
	\caption{Lista de páginas exibidas no menu de layout em pilha}
\end{figure}

\begin{figure}[H]
	\includegraphics[width=8cm]{exemplo_menu_layout_em_linha}
	\centering
	\caption{Lista de páginas exibidas no menu de layout em linha}
\end{figure}


\subsubsection{Gerenciamento de Plugins}
A classe \textit{PluginManager} é responsável por carregar os plugins, basicamente, iterando os arquivos dentro do diretório \textit{plugins} e analisando as propriedades do arquivo de configuração de cada plugin. Em cada arquivo, o objeto verificará as definições de cada página, transformando cada item em um objeto e adicionado em uma lista. Após ler todos os plugins, o array de objetos será persistido nas configurações da aplicação para que na próxima inicialização não precise iterar novamente o diretório, lendo as definições dos plugins das configurações. Os plugins serão recarregados após uma atualização do aplicativo ou quando a aplicação for executada em modo \textit{debug}.\par
A cada inicialização, será feito uma verificação da versão do aplicativo, que será persistida nas configurações na primeira execução e sobre-escrita a cada atualização. Se houver diferença entre versão em execução da versão salva anteriormente (se houver), os plugins serão recarregados. Além disso, esta classe também é responsável por deletar todos os arquivos de cache contido no diretório de cache da aplicação a cada \textit{release}. Outra responsabilidade dessa classe, é a criação da tabela do plugin no banco de dados do aplicativo, se existir um arquivo \textit{plugin\_table.sql} no diretório do plugin. O banco de dados da aplicação será criado por outro objeto que controla as operações de persistência e será detalhado em outra seção. O diagrama a seguir, apresenta as operações e atributos da classe \textit{PluginManager}.

\begin{figure}[H]
	\includegraphics[width=8cm]{diagrama_de_classe_PluginManager}
	\centering
	\caption{Diagrama da classe PluginManager}
\end{figure}

O carregamento dos plugins será feito na inicialização do aplicativo, antes de instanciar qualquer componente visual, na invocação do método \textit{loadPlugins}.


\subsection{Gerenciamento de Configurações}
A arquitetura provê uma API simples e de alto nível para persistir dados utilizando o conceito \textit{chave-valor} através de invocação síncrona. Nesse modelo de persistência, a chave identifica o dado a ser armazenado e o valor é o dado propriamente dito. Os tipos de dados são: strings, números, objetos ou arrays e os métodos disponíveis podem ler, persistir ou deletar. As aplicações simples baseadas nesta arquitetura que não precisam de \textit{SQLITE}, poderão utilizar esse mecanismo para persistir dados no dispositivo. Essa API é provida através da classe \textit{Settings} descrita a seguir.

\subsubsection{A classe Settings}
A classe \textit{Settings} é um componente importante nesta arquitetura e suas principais responsabilidades consiste em carregar o arquivo de configuração \textit{config.json} e gerenciar a persistência das configurações do aplicativo via \textit{QSettings}\footnote{https://doc.qt.io/qt-5/qsettings.html.}. \textit{Settings} será instanciada na inicialização do aplicativo e registrada no contexto da aplicação identificada como um objeto global \textit{"Settings"} para que os plugins possam invocar seus métodos públicos. O arquivo de configuração será convertido em um objeto javascript e registrado no contexto da aplicação como um objeto global em modo leitura, referenciado por \textit{"Config"}. \textit{Settings} adicionará o \textit{path} de cada plugin em uma propriedade no objeto \textit{Config} para que os plugins possam acessar os seus arquivos usando uma sintaxe mais legível (via \textit{Config.plugins.plugin\_directory\_name}). Por exemplo, considerando que \textit{Session} é um plugin, os arquivos em seu diretório poderão ser acessados da seguinte forma: \textit{Config.plugins.session + "File.qml"}. O objetivo dessa propriedade é fornecer aos plugins uma forma simplificada de acessar os arquivos em seu diretório, visto que os plugins serão colocados em diretórios virtuais nas plataformas \textit{mobile}: \textit{"assets://"} no android e "assets\_catalogs://" no ios. Quando executado em desktop, será utilizado o caminho absoluto de cada arquivo. \textit{Settings} também dispõe ainda de seis atributos booleanos que indicam qual a plataforma o aplicativo está sendo executado. A estrutura da classe \textit{Settings} será apresentada na Figura 7.

\begin{figure}[H]
	\includegraphics[width=8cm]{diagrama_de_classe_Settings}
	\centering
	\caption{Diagrama da classe Settings}
\end{figure}

\textit{Settings} é quem define o estilo de \textit{widgets} utilizado pelos componentes QML (Material, Universal, etc.). A definição do estilo deve ser feito pelo desenvolvedor no arquivo de configuração na propriedade \textit{applicationStyle} que será passado para um objeto \textit{QQuickStyle} do Qt na inicialização. Os possíveis valores para esta propriedade serão detalhados na seção que descreve o arquivo \textit{config.json}.\par

Os métodos da classe \textit{Settings} serão descritos a seguir, seguido de um exemplo de como utilizá-los:
	\begin{itemize}
		\item \textit{read}: Utilizado para ler um dado salvo utilizando uma string que identifique a informação a ser retornada. Por padrão, o tipo de retorno é string. Porém, se o dado não for string, o segundo parâmetro deve ser passado indicando o tipo específico a ser retornado. Os tipos podem ser especificados para evitar o uso de \textit{cast} no QML. Os tipos possíveis são:
		\begin{itemize}
			\item \textit{TypeBool}: para retornar um valor booleano;

			\item \textit{TypeInt}: para retornar um inteiro;

			\item \textit{TypeStringList}: para retornar uma lista de strings;

			\textit{TypeJsonObject}: para retornar um objeto;

			\item \textit{TypeJsonArray}: para retornar um array de objetos.
		\end{itemize}

		\item \textit{save}: Utilizado para persistir alguma informação. Esse método é \textit{void} e possui dois parâmetros requeridos. O primeiro é uma string que identifica o dado a ser persistido, e o segundo, é o dado que será armazenado. O dado pode ser uma string, um valor numérico, um objeto ou array json.

		\item \textit{remove}: Utilizado para apagar alguma informação das configurações. Esse método requer apenas um parâmetro, uma string que identifica o dado a ser deletado.
	\end{itemize}

O Exemplo 2, demostra como ler e persistir de dados usando o mecanismo \textit{chave-valor} a partir do objeto \textit{Settings}:

\begin{center}
\begin{lstlisting}[language=qml,caption={Persistência de dados usando chave-valor},captionpos=b]
import QtQuick 2.8

Item{
    Component.onCompleted:{
		var foo = Settings.read("foo")
		if (bar != foo)
		   Settings.save("foo",bar)
		Settings.remove("bar")
    }
}
...
Item{
	...
	key:"bar"
	count:Settings.read(key,Settings.TypeInt)
	...
	Component.onCompleted:{ 
		Settings.save(key,++count)
	}
}
\end{lstlisting}
% \captionof{lstlisting}{Exemplo de persistência através do objeto \textit{Settings}}
\end{center}


\subsection{O Arquivo de Configuração}
O arquivo \textit{config.json} presente na raiz do projeto é um componente importante nesta arquitetura e contém as definições de configuração do aplicativo. No entanto, as informações desse componente não serão persistidas e o conteúdo (propriedades e valores) será passado para a aplicação como um objeto javascript global. As propriedades listadas a seguir, serão utilizadas por componentes internos e o desenvolvedor poderá adicionar outras propriedades quando for necessário compartilhar informações entre os plugins. Os plugins poderão ler as propriedades declaradas neste arquivo via \textit{Config.property\_name}. As propriedades definidas inicialmente e utilizadas pela aplicação serão descritas a seguir:

\begin{itemize}
	\item \textit{applicationName} (string): O nome do aplicativo. Este valor será passado para o Qt na inicialização da aplicação. O valor dessa propriedade será utilizado para definir o nome dos arquivos de configuração (\textit{QSettings}) e do banco de dados \textit{SQLITE} (quando houver);

	\item \textit{organizationName} (string): O nome da organização do aplicativo. Este valor também será passado para o Qt na inicialização do aplicativo e será utilizado para nomear e identificar o diretório de configurações e cache do aplicativo;

	\item \textit{organizationDomain} (string): O endereço de domínio da organização, por exemplo, \textit{qt.project.org}. O valor dessa propriedade será utilizado pelo Qt internamente;

	\item \textit{applicationStyle} (string): O nome do estilo a ser aplicado nos \textit{widgets} (\textit{Button}, \textit{TabBar}, \textit{ToolTip} etc.) do \textit{Quick Controls}. Os possíveis valores são: \textit{Material}, \textit{Universal} ou \textit{Default};

	\item \textit{forceEulaAgreement} (bool): Um valor booleano que indica se a aplicação deverá exigir do usuário confirmação de aceitação dos termos de uso para continuar usando o aplicativo. Esse valor só terá efeito se a propriedade \textit{showEula} for definida para \textit{true};

	\item \textit{hasLogin} (bool): Um valor booleano que indica se o aplicativo deverá carregar uma página de login na inicialização. Se for definido para \textit{true}, a aplicação irá utilizar a página que definiu (dentre os plugins) \textit{isLoginPage} para \textit{true};

	\item \textit{showEula} (bool): Um valor booleano que indica se a aplicação exibirá para o usuário uma página contendo os termos de uso do aplicativo. Caso seja setado para \textit{true}, o arquivo \textit{assets/eula.html} será carregado e exibido na primeira execução do aplicativo. Após o usuário ler e aceitar os termos de uso, o usuário irá para a página de login ou a \textit{home page}. No entanto, se essa propriedade for utilizada o desenvolvedor deverá escrever os termos de uso no arquivo \textit{assets/eula.html};

	\item \textit{showTabButtonText} (bool): Um valor booleano que indica se o título da página será exibida nos botões do menu em linha (\textit{TabButton} do \textit{Quick Controls}). Essa propriedade terá efeito somente quando a aplicação tiver usando o layout em linha;

	\item \textit{usesSwipeView} (bool): Um valor booleano que indica se o layout principal do aplicativo será em linha. Caso essa propriedade seja \textit{true}, o aplicativo utilizará o container \textit{SwipeView} do \textit{Quick Controls}. No entanto, o container responsável pelo layout em pilha (\textit{StackView}) ainda continuará disponível na aplicação, porém como container secundário. Um objeto fará o \textit{Binding} entre ambos, ocultando o \textit{SwipeView} quando alguma página for adicionada a pilha do \textit{StackView}. No \textit{SwipeView} o usuário poderá alternar entre as páginas deslizando horizontalmente;

	\item \textit{usesDrawer} (bool): Um valor booleano que indica se o menu lateral usado no layout em pilha, será instanciado. Essa propriedade terá efeito apenas no layout em linha, ou seja, se \textit{usesSwipeView} for \textit{true}, pois no layout em pilha ele será instanciado mesmo que o valor seja \textit{false}. O objetivo dessa propriedade é permitir que o desenvolvedor possa utilizar o menu lateral junto com o \textit{SwipeView}, intercalando as páginas que serão visíveis em cada um dos menus através das propriedades \textit{showInDrawer} e \textit{showInTabBar} na configuração das páginas de cada plugin;

	\item \textit{showDrawerImage} (bool): Um valor booleano que indica se a imagem do menu será carregada. Por padrão a imagem não será exibida. Se essa propriedade for definida para \textit{true}, a imagem definida em \textit{assets/drawer.jpg} será utilizada e o desenvolvedor poderá substituí-la por uma de sua preferência;

	\item \textit{restService} (object): Um objeto contendo as definições do serviço \textit{RESTful}, como url base e os parâmetros de autenticação básica (\textit{Basic Authentication}) usuário e senha. Os valores das propriedades \textit{userName} e \textit{userPass} serão convertidos em um \textit{hash} \textit{base64} e passado no cabeçalho de cada requisição HTTP. As seguintes propriedades são requeridas:

	\begin{itemize}
		\item \textit{userName} (string): O nome do usuário do serviço \textit{RESTful};

		\item \textit{userPass} (string): A senha de usuário do serviço \textit{RESTful};

		\item \textit{baseUrl} (string): A url base do serviço \textit{RESTful}. Essa propriedade será utilizada pelo objeto \textit{RequestHttp} nos métodos de requisições \textit{GET}, \textit{POST} etc. A sugestão é que o desenvolvedor adicione apenas o \textit{path} nos objetos que fazem requisições HTTP. Desta forma, se a url do \textit{web service} for modificada, basta alterar apenas no arquivo de configuração. Internamente, o objeto que realiza requisições concatenará o valor dessa propriedade com o \textit{path} passado no primeiro parâmetro dos métodos.
	\end{itemize}

	\item \textit{fontSize} (object): Um objeto com as definições de valores inteiros para os tamanhos de fonte a serem utilizadas em elementos textuais tais como o \textit{Label}. Essa propriedade possui quatro atributos: \textit{small}, \textit{normal}, \textit{large} e \textit{extraLarge};

	\item \textit{theme} (object): Um objeto com as definições de cores utilizada nos elementos visuais, tais como Botões, \textit{ToolBar}, \textit{TabBar}, cor de fundo das páginas e cor de fundo do \textit{drawer};

	\item \textit{events}: (array): Um array de strings com os eventos utilizados pelos plugins e pode ser adicionado pelo desenvolvedor. Essa propriedade será utilizada por objetos \textit{observer} para identificar de qual evento estão sendo notificados, e o objetivo é padronizar os nomes dos eventos e reduzir a replicação de strings. Os objetos da aplicação podem disparar eventos através de uma instância da classe \textit{Subject}, via \textit{procedure call} com a seguinte notação: \textit{Subject.notify(Config.events.foo, null)}. Os observadores do evento \textit{"foo"} serão notificados recebendo o argumento \textit{null}. O objeto \textit{Settings} adicionará treze itens neste array que identificam os eventos disparados por objetos internos da aplicação. Esses valores podem ser utilizados pelos plugins para executarem ações específicas em dado momento. Os eventos adicionados pelo objeto \textit{Settings} serão descritos a seguir:

	\begin{itemize}
		\item \textit{cameraImageSaved} (string): Utilizado para notificar observadores de que uma imagem foi capturada pela câmera do dispositivo e salva localmente. Para utilizar a câmera do dispositivo, a arquitetura dispõe de um componente QML \textit{CameraCapture} que pode ser utilizado pelos plugins para permitir ao usuário capturar uma imagem. A url da imagem salva será passado no argumento do evento como uma string;

		\item \textit{cancelSearch} (string): Utilizado pelo \textit{ToolBar} para indicar que o campo de busca não está ativo e notificar a página ativa que atualize o conteúdo para o usuário. O \textit{ToolBar} possui um campo texto para pesquisa e ficará visível quando a página alterar o valor da propriedade \textit{toolBarStatus} (string) para \textit{"search"}. Essa funcionalidade permitirá que uma página filtre os resultados exibidos na sua \textit{view}, recebendo em um atributo string \textit{searchText} o valor digitado no campo. O usuário poderá cancelar a busca clicando em um botão voltar que ficará visível ao lado esquerdo do campo de busca e nesse momento, este evento será disparado;

		\item \textit{logoutApplication} (string): Utilizado pelo objeto \textit{UserProfile} para atualizar o status da propriedade \textit{isUserLoggedIn} para \textit{false} e em seguida carregar na página de login. No entanto, esse evento deverá ser utilizado quando houver login na aplicação e deve ser disparado por algum plugin;

		\item \textit{newActionNotification} (string): Utilizado para notificar a aplicação quando o usuário clicar em uma notificação e o aplicativo ficar em \textit{foreground}, válido para notificações via \textit{push} e local. Esse evento será disparado pela atividade do Android (\textit{CustomActivity}) e pelo objeto \textit{QtAppDelegate} no iOS, repassando para a aplicação um objeto como argumento do evento. O argumento do evento (\textit{eventData}) conterá os dados da mensagem em uma string sendo necessário fazer o \textit{parsing} caso seja um objeto json;

		\item \textit{newPushNotification} (string): Utilizado sempre que uma notificação via \textit{push} chegar no dispositivo e o mesmo estiver em execução, em \textit{foreground} ou \textit{background}. Ele será disparado a partir dos serviços de notificação que executam em outro processo e serão repassados para a aplicação através de uma conexão entre o objeto java \textit{CustomAtivity} no android e o \textit{QtAppDelegate} no iOS. O argumento do evento (\textit{eventData}), conterá os dados da mensagem em uma string sendo necessário fazer o \textit{parsing} caso seja um objeto json;

		\item \textit{newPushNotificationToken} (string): Utilizado quando o registro no \textit{Firebase} for realizado com sucesso. Esse evento será disparado por objetos que executam em outro processo e serão passados para a aplicação através de uma conexão entre o objeto java \textit{CustomAtivity} no android e o \textit{QtAppDelegate} no iOS. O argumento do evento (\textit{eventData}) conterá o token em uma string;

		\item \textit{openDrawer} (string): Utilizado intermante para abrir o menu do layout em pilha quando o usuário clicar no botão de menu, posicionado no canto esquerdo do \textit{ToolBar}. O menu do layout em pilha fica oculto por padrão e o usuário poderá torná-lo visível arrastando da esquerda para a direita na janela do aplicativo;

		\item \textit{popCurrentPage} (string): Esse evento deverá ser disparado quando for necessário remover a página ativa da pilha do \textit{StackView}. Será disparado internamente pelo \textit{ToolBar} quando o usuário clicar no botão voltar (seta para a esquerda, exibido se a página definir a propriedade \textit{toolBarState} para \textit{"goBack"}) ou quando o botão \textit{back-button} do android for pressionado. O \textit{StackView} por exemplo, removerá a página da pilha quando este evento for emitido;

		\item \textit{appendOptionPage} (string): Esse evento pode ser utilizado para adicionar um novo item na lista de opções do menu. Esse evento poderá ser utilizado em ambos os layouts em pilha ou em linha e o argumento do evento deve ser um objeto contendo as propriedades de uma página utilizado no \textit{config.json} de um plugin;

		\item \textit{requestUpdateUserProfile} (string): Esse evento deve ser emitido para atualizar as informações ou dados do usuário no objeto \textit{UserProfile}. Por exemplo, uma página que permite editar os dados do usuário em um formulário, após o usuário atualizar alguma informação, a página poderá emitir esse evento passando como argumento um objeto contendo as informações do usuário no estilo \textit{chave-valor}. O objeto \textit{UserProfile} observará esse evento e salvará as informações localmente;

		\item \textit{initUserProfile} (string): Esse evento deve ser utilizado para inicializar o perfil do usuário após o login, recebendo um objeto json contendo as informações que serão persistidas localmente. O json deverá ser passado no argumento do evento, contendo no mínimo as propriedades \textit{id} e \textit{email}. Um exemplo de uso deste evento, pode ser feito pela página de login, após sucesso na autenticação. A página de login poderá emitir esse evento e passar como argumento o objeto retornado pelo serviço \textit{REST}. O objeto \textit{UserProfile} observará esse evento e quando o mesmo for emitido, salvará os dados do usuário na propriedade \textit{profile}. Em seguida, a propriedade \textit{isLoggedIn} será atualizada para \textit{true} e a \textit{home page} será carregada;

		\item \textit{setUserProfileData} (string): Esse evento também deve ser utilizado quando houver um perfil de usuário e permitirá adicionar ou atualizar uma informação no perfil do usuário. Logo, o argumento do evento deve conter a propriedade \textit{key} indicando o nome da propriedade a ser adicionada e \textit{value} contendo o respectivo valor. Por exemplo, o seguinte objeto pode ser utilizado como argumento deste evento: \textit{\{"key": "username", "value": "enoque"\}};

		\item \textit{userProfileChanged} (string): Esse evento será disparado pelo objeto \textit{UserProfile} sempre que ocorrer alguma atualização nos dados do usuário. No argumento do evento será passado uma referência para o objeto \textit{profile}.
	\end{itemize}
\end{itemize}


\subsection{Acesso a Rede (HTTP)}
O acesso a rede é um requisito funcional provido nesta arquitetura e o objetivo é permitir a comunicação entre o aplicativo e um serviço \textit{RESTful} de forma facilitada. Para disponibilizar o uso de rede pelos plugins, foi criado uma classe C++ com suporte a autenticação básica, \textit{download} e \textit{upload} de arquivos, além de requisições via \textit{GET}, \textit{POST} e \textit{PUT}. O objetivo dessa classe é oferecer um componente rico em recursos, com bom desempenho e de alto nível para os plugins. Os plugins que utilizarem requisições HTTP, receberão a resposta de cada pedido através de objetos json dispensando o uso de \textit{parsing}. Para simplificar o uso da API de rede, o desenvolvedor deverá adicionar na propriedade \textit{restService} no arquivo de configuração, a url do serviço \textit{RESTful} em \textit{baseUrl} e o nome e a senha do usuário em \textit{userName} e \textit{userPass} respectivamente. O objetivo é que o desenvolvedor utilize apenas o \textit{path} da url nos métodos de requisições. A subseção a seguir, descreve os detalhes da classe \textit{RequestHttp} seguido de exemplos de como instanciá-la e como fazer requisições ao \textit{web service} do aplicativo.

\subsubsection{A classe RequestHttp}
A classe \textit{RequestHttp} será registrada como um tipo QML no contexto da aplicação e para instanciá-la basta adicionar a diretiva \textit{import RequestHttp 1.0} e em seguida, declarar um objeto QML \textit{RequestHttp}. Internamente, os objetos inicializarão os atributos \textit{baseUrl}, nome de usuário e senha, mas, o desenvolvedor pode sobrescrevê-los quando for necessário. Essa classe utiliza \textit{QNetworkAccessManager} para gerenciar as operações de rede abstraindo para o aplicativo a interface de rede utilizada no dispositivo e \textit{QNetworkRequest} para encapsular os parâmetros da requisição. Os atributos e métodos disponíveis serão descritos a seguir. O Exemplo 3 demonstra como instanciar a classe \textit{RequestHttp}.

\begin{itemize}
	\item \textit{baseUrl} (string): atributo que define o endereço base do serviço \textit{REST}. Não precisa ser definido, pois será feito automaticamente no construtor do objeto. Porém, poderá ser utilizado pelo desenvolvedor quando a url definida no arquivo de configuração for diferente da url de destino de uma requisição específica;

	\item \textit{authorizationUser} (string): atributo que define o nome do usuário do serviço \textit{REST}. Também não precisa ser definido, mas está disponível para que o desenvolvedor possa fazer requisições a uma url ou serviço com outro nome de usuário, além do que está definido no arquivo de configuração;

	\item \textit{authorizationPass} (string): atributo que define a senha do usuário do serviço \textit{REST}. Também não precisa ser definido, mas poderá ser modificado pelo desenvolvedor quando for preciso;

\begin{center}
\begin{lstlisting}[language=qml,caption={Instanciando a classe RequestHttp},captionpos=b]
import QtQuick 2.8
import RequestHttp 1.0

RequestHttp{
	id:requestHttp
	baseUrl:"https://static.api.foo.com"
	authorizationUser:"foo"
	authorizationPass:"bar.2018"
}
...
Item{
	Component.onCompleted:{
		var queryString = {
			arg1:"123",
			arg2:"321"
		}
		requestHttp.get("bar",queryString)
	}
}
\end{lstlisting}
\end{center}

	\item \textit{get}: método que realiza requisições do tipo \textit{GET} exigindo apenas a url de destino. Esse método possui dois parâmetros opcionais, o primeiro deles é um objeto do tipo \textit{chave-valor} e se for passado, adicionará a url uma \textit{query-string}. O segundo parâmetro opcional é também um objeto e pode ser passado quando for necessário adicionar dados no cabeçalho da requisição. O Exemplo 4, demonstra como fazer requisições do tipo GET;
\begin{center}
\begin{lstlisting}[language=qml,caption={Requisição do tipo GET via RequestHttp},captionpos=b]
import QtQuick 2.8
import RequestHttp 1.0

RequestHttp{
	id:requestHttp
}
...
Item{
	Component.onCompleted:{
		var queryString = {
			someKey:"foo",
			paginate:listView.count
		}
		//...foo?someKey=foo&paginate=16
		requestHttp.get("foo",queryString)
	}
}
\end{lstlisting}
\end{center}

	\item \textit{post}: método que realiza requisições do tipo \textit{POST} exigindo a url de destino e o dado a ser postado em formato string. O terceiro parâmetro desse método é opcional e pode ser passando quando for necessário adicionar dados no cabeçalho da requisição. É importante destacar que o \textit{Content-Type} será sempre \textit{application/json} e se o método post exigir outros formatos tais como o \textit{x-www-form-urlencoded}, o desenvolvedor deverá passar um objeto (\textit{Content-Type: [Type]}) como argumento extra no cabeçalho da requisição através do terceiro parâmetro desse método. O Exemplo 5, apresenta uma requisição que utiliza esse método:
\begin{center}
\begin{lstlisting}[language=qml,caption={Requisição do tipo POST via RequestHttp},captionpos=b]
import QtQuick 2.8
import RequestHttp 1.0

RequestHttp{
	id:requestHttp
}
...
Item{
	Component.onCompleted:{
		var postData = JSON.stringfy({
			someKey:"bar",
			email:textField.text
		})
		requestHttp.post("bar",postData)
	}
}
\end{lstlisting}
\end{center}

	\item \textit{uploadFile}: realiza uma requisição do tipo \textit{POST} ou \textit{PUT} exigindo a url de destino e um array de strings contendo os endereços dos arquivos locais a serem enviados para o servidor. A requisição será do tipo \textit{multipart-formdata} e do tipo \textit{POST} (por default). O terceiro parâmetro (booleano, default \textit{false}) pode ser passado quando for necessário utilizar o método \textit{PUT}. Já o último parâmetro, poderá ser passado quando for necessário adicionar dados no cabeçalho da requisição. Após invocar esse método, o sinal \textit{uploadFinished} será emitido para cada arquivo enviado. Durante o envio de cada arquivo, será emitido o sinal \textit{uploadProgressChanged} contendo os bytes do arquivo (local) e o total de bytes já enviados para o servidor. O Exemplo 6, apresenta uma requisição do tipo POST para upload de arquivos ao serviço \textit{REST}:
\begin{center}
\begin{lstlisting}[language=qml,caption={Upload de arquivos via RequestHttp},captionpos=b]
import QtQuick 2.8
import RequestHttp 1.0
	
RequestHttp{
	id:requestHttp
}
...
Item{
	Component.onCompleted:{
		var files = [
			"/data/app/myapp/files/img1.png",
			"/data/app/myapp/files/img2.png"
		]
		requestHttp.upload("bar",files)
	}
}
\end{lstlisting}
\end{center}

	\item \textit{downloadFile}: realiza uma requisição do tipo \textit{GET} exigindo apenas uma lista de urls de arquivos a serem baixados para o dispositivo. Por padrão, os arquivos serão salvos no diretório público de \textit{downloads} no dispositivo. No entanto, o segundo parâmetro \textit{saveInAppDirectory} (booleano, default \textit{false}) pode ser utilizado para alterar o diretório de destino dos arquivos para uma pasta interna do aplicativo. Após invocar esse método, para cada arquivo salvo, o sinal \textit{downloadFileSaved} será emitido passando o \textit{path} do arquivo salvo localmente. Durante o download de cada arquivo, o sinal \textit{downloadProgressChanged} será emitido passando dois argumentos, o primeiro indica o total de bytes do arquivo que está sendo baixado e o segundo, um valor inteiro indicando os bytes que já foram baixados. O Exemplo 7, demonstra uma requisição para download de arquivos a partir de duas urls:
\begin{center}
\begin{lstlisting}[language=qml,caption={Download de arquivos via RequestHttp},captionpos=b]
import QtQuick 2.8
import RequestHttp 1.0
	
RequestHttp{
	id:requestHttp
}
...
Item{
	Component.onCompleted:{
		var urls = [
			"https://.../files/f1.png",
			"https://.../files/f2.png"
		]
		requestHttp.downloadFile(urls)
	}
}
\end{lstlisting}
\end{center}

\end{itemize}

Os métodos descritos anteriormente são todos \textit{void}, assíncronos e declarados como \textit{Q\_INVOKABLE} \footnote{htps://doc.qt.io/qt-5/qtqml-cppintegration-exposecppattributes.html} para permitir o uso dos métodos em componentes QML. Para obter a resposta de uma requisição, é preciso criar uma conexão com o sinal \textit{finished} usando o objeto \textit{Connections}\footnote{http://doc.qt.io/archives/qt-4.8/qml-connections.html} do QML, especificando como \textit{target} o objeto \textit{requestHttp}. O sinal \textit{finished} será emitido por todos os métodos da classe \textit{RequestHttp} descritos anteriormente quando não houver erros no pedido e logo após o envio da resposta pelo servidor. O sinal \textit{finished} passará dois argumentos: \textit{statusCode} — um valor inteiro indicando o status da resposta (200, 400, 500, etc.) e \textit{response} — o dado da resposta enviado pelo servidor. Se a resposta enviada pelo servidor for um json válido, \textit{response} será convertido em objeto ou array javascript, caso contrário, uma string contendo o dado bruto.\par

O sinal \textit{error} será emitido quando houver erros em um pedido e passará dois argumentos, \textit{statusCode} (integer) indicando o código HTTP correspondente ao erro, e \textit{message} (string) contendo a mensagem do erro.\par

A propriedade \textit{status} (integer) declarada como \textit{Q\_PROPERTY}\footnote{http://doc.qt.io/qt-5/properties.html} indicará o \textit{status} atual de uma requisição. Essa propriedade pode ser comparada com qualquer uma das seguintes meta-propriedades (útil para fazer \textit{bindings} com outros objetos):

\begin{itemize}
	\item \textit{Error}: indica um erro no pedido, quando o servidor não responder ou o status da requisição for zero;

	\item \textit{Finished}: indica que a requisição terminou e será setada em \textit{status} antes da emissão do sinal \textit{finished};

	\item \textit{Loading}: indica que a requisição está em andamento ou carregando;

	\item \textit{Ready}: indica que a requisição está pronta, será setada em \textit{status} no construtor e logo após a emissão do sinal \textit{finished}.
\end{itemize}

O trecho de código no Exemplo 8, demonstra como criar um \textit{Bind} entre o status de uma requisição e uma propriedade de um objeto \textit{Button}.

\begin{center}
\begin{lstlisting}[language=qml,caption={\textit{Bind} com o status de uma requisição},captionpos=b]
import RequestHttp 1.0

RequestHttp{
	id:request
}
...
Button{
	text:"Submit"
	enabled:request.status == request.Ready
	onClicked:request.get("foo",{"bar":1})
}
...
\end{lstlisting}
\end{center}


O diagrama a seguir, apresenta os atributos e métodos da classe \textit{RequestHttp}:

\begin{figure}[h]
	\includegraphics[width=8cm]{diagrama_de_classe_RequestHttp}
	\centering
	\caption{Diagrama da classe \textit{RequestHttp}}
\end{figure}


\subsection{Persistência de Dados}
Persistência de dados é um requisito funcional implementado e disponível nesta arquitetura e visa fornecer aos plugins a possibilidade de persistir dados em um banco \textit{SQLITE} e o funcionamento \textit{offline} do aplicativo com maior robustez. Cada plugin pode criar uma ou mais tabelas no banco de dados e realizar as operações de inserção, atualização e busca de dados em suas tabelas, basta importar o componente \textit{Database} com a diretiva \textit{import Database 1.0} e declarar um objeto QML. Para criar as tabelas no banco de dados do aplicativo, o plugin deve fornecer um arquivo \textit{plugin\_table.sql} em seu diretório, contendo os comandos de criação, alteração ou remoção das tabelas. A cada \textit{release}, esse arquivo será carregado e executado como uma \textit{query} sql permitindo aos plugins atualizar as tabelas (adicionar, remover ou modificar as colunas) quando for necessário.\par

Para gerenciar as operações de banco de dados, foi criado uma classe C++ chamada \textit{Database} que encapsula em métodos de alto nível as operações necessárias para criar o banco de dados, conectar e executar as operações sql. No entanto, essa classe não será utilizada pelos plugins diretamente, foi criado outra classe chamada \textit{DatabaseComponent} que agrega uma instância de \textit{Database} e delegará as operações para esse objeto. \textit{DatabaseComponent} fornecerá alguns recursos para simplificar ainda mais a persistência de dados. As subseções a seguir apresentam detalhes de ambas as classes \textit{Database} e \textit{DatabaseComponent}.

\subsubsection{A classe Database}
A classe \textit{Database} é responsável por criar o banco de dados \textit{SQLITE} na primeira execução do aplicativo se houver necessidade, ou seja, se algum plugin dispor de um arquivo \textit{plugin\_table.sql} em seu diretório e será instanciada pelo objeto \textit{PluginManager} para criar a tabela do plugin. Se nenhum plugin fornecer esse arquivo, o banco de dados \textit{SQLITE} não será criado. A classe \textit{Database} utiliza as classes \textit{QSqlDatabase} para criação e conexão com o banco de dados e as classes \textit{QSqlQuery} e \textit{QSqlRecord} para as realizar \textit{querys} e retornar os resultados das consultas. Os métodos principais desta classe serão descritos a seguir:

\begin{itemize}
	\item \textit{tableColumns}: esse método retorna uma lista de strings contendo os nomes das colunas da tabela especificada no único parâmetro do método;

	\item \textit{createTable}: esse método é invocado pelo gerenciador de plugins quando houver um arquivo sql para criação de uma tabela no banco \textit{SQLITE} do aplicativo. Ele requer um único parâmetro string com o path do arquivo contendo os comandos de criação da tabela do plugin;

	\item \textit{select}: esse método pode ser utilizado para recuperar dados de uma tabela através de uma consulta \textit{sql} e possui três parâmetros, o primeiro é nome da tabela onde será feito a consulta, o segundo é um objeto contendo os parâmetros da consulta (condição \textit{where}) no estilo \textit{nome-da-coluna.valor}, e o último parâmetro, um outro objeto contendo argumentos adicionais, tais como \textit{limit}, \textit{offset} e \textit{order by}. Esse método retornará uma lista de objetos resultante da consulta, e cada objeto contido na lista é composto de \textit{nome-da-coluna.valor}. Se a consulta não for efetuada com sucesso, será retornado uma lista vazia;

	\item \textit{insert}: esse método pode ser utilizado para inserir dados em uma tabela e os parâmetros requeridos são: o nome da tabela onde será feito a inserção e um objeto no estilo \textit{nome-da-coluna.valor} contendo os dados a serem persistidos. Se a inserção for efetuada com sucesso e a tabela possuir uma coluna auto-incrementada como chave-primária o valor incrementado será retornado. Caso contrário, não possuir a coluna auto-incrementada, retornará o valor inteiro 1 (um) ou, retornará zero se houver erros na inserção;

	\item \textit{remove}: esse método pode ser utilizado para deletar um ou mais registros em uma tabela e três parâmetros são requeridos: o primeiro é o nome da tabela onde será feito a remoção, o segundo é um objeto contendo os argumentos ou filtros da \textit{query} no estilo \textit{nome-da-coluna.valor}. O terceito parâmetro é opcional e pode ser passado para customizar o operador de comparação para cada par \textit{nome-da-coluna.valor} no segundo parâmetro. Por default, será utilizado o operador de igualdade ("=");

	\item \textit{update}: esse método pode ser utilizado para atualizar um ou mais registros em uma tabela específica. Os parâmetros desse método são basicamente os mesmos do método \textit{remove} descrito no item anterior, com uma adição, o parâmetro \textit{updateData}, um objeto contendo os dados a serem atualizados também no estilo \textit{nome-da-coluna.valor};

	\item \textit{queryExec}: esse método pode ser utilizado para realizar uma consulta sql a partir de uma string passada como parâmetro. O valor booleano \textit{true} será retornado se a \textit{query} for efetuada com sucesso, caso contrário \textit{false}. O resultado da consulta se houver, deverá ser obtido através do método \textit{resultSet} descrito a seguir;

	\item \textit{resultSet}: esse método pode ser utilizado para recuperar um conjunto de dados resultante da última consulta sql efetuada, por exemplo, após a chamada ao método \textit{queryExec}. O tipo de retorno é uma lista de objetos no estilo \textit{nome-da-coluna.valor}. O método \textit{select} por exemplo, utiliza esse método como retorno da consulta efetuada internamente. Esse método possui um parâmetro opcional que deve ser utilizado quando a tabela a qual a última consulta efetuada for do tipo \textit{meta\_key.meta\_value} para que a chave do objeto seja a chave na tabela e o valor, o dado contido em meta\_value;
\end{itemize}

É importante destacar, que essa classe é um \textit{singleton} e será instanciada na inicialização do aplicativo pelo objeto \textit{PluginManager}. Se múltiplos plugins realizarem operações sql, eles utilizarão a mesma instância dessa classe. O diagrama a seguir apresenta os atributos e métodos da classe \textit{Database}.

\begin{figure}[h]
	\includegraphics[width=8cm]{diagrama_de_classe_Database}
	\centering
	\caption{Diagrama da classe Database}
\end{figure}

\subsubsection{A classe DatabaseComponent}
A classe \textit{DatabaseComponent} foi criada com o objetivo de fornecer um componente de alto nível que simplificasse para os plugins as operações em uma tabela específica. Essa classe será registrada no contexto da aplicação como um tipo QML com o nome de "\textit{Database}" e permitirá aos plugins a utilizarem declarando um objeto QML. \textit{DatabaseComponent} agrega uma instância da classe \textit{Database} e delega as operações para esse objeto. No entanto, ela possui alguns atributos (\textit{Q\_PROPERTY}) que permitem aos plugins informar o nome da tabela no banco de dados, o nome da chave-primária do tipo string (quando a chave-primária não for numérica auto-incrementada), além de colunas que guardam objetos json. As colunas json evitam que os plugins tenham que fazer \textit{parsing} nas views. Outro atributo \textit{totalItens}, manterá atualizado o número de registros na tabela para fins de comparação entre o número de itens disponível no serviço \textit{REST} com os itens já baixados para o dispositivo, útil para paginação de dados na \textit{view}. O diagrama a seguir, apresenta os atributos e métodos dessa classe:

\begin{figure}[H]
	\includegraphics[width=8cm]{diagrama_de_classe_DatabaseComponent}
	\centering
	\caption{Diagrama da classe DatabaseComponent}
\end{figure}

Os métodos de busca, inserção, remoção e atualização presentes em \textit{DatabaseComponent} foram simplificados para que os plugins informem apenas os parâmetros da consulta sem o nome da tabela. Outro recurso importante é que o método de busca (\textit{select}) é assíncrono e os resultados de uma consulta, quando houver, serão retornados através do sinal \textit{itemLoaded} que passará como argumento, um objeto no estilo \textit{nome-da-coluna.valor}. \textit{DatabaseComponent} possui ainda o método \textit{containsId} que verifica se um item (pela chave primária) já está salvo localmente e pode ser útil para sincronizar com a \textit{view} os itens já baixados do serviço \textit{REST}. O Exemplo 9, demonstra como um plugin poderá utilizar \textit{DatabaseComponent} referenciada apenas como \textit{Database} para ler e persistir dados:

\begin{center}
\begin{lstlisting}[language=qml,caption={Instanciando a classe Database para persistir dados},captionpos=b]

import Database 1.0
...
Database{
	id:database
	jsonColumns:["source"]
	tableName:"news"
	pkColumn:"title"
	onItemLoaded:listViewModel.append(entry)
}
...
Item{
	Component.onCompleted:{
		var args = {
			title:"GNU is not Unix!",
			message:"GNU is an operating...",
			source:{
				a:"foo", b:"bar",c:"baz"
			}
		}
		database.insert(args)
	}
}
...
\end{lstlisting}
\end{center}


\subsection{Notificações do Aplicativo}
Notificações do aplicativo é um requisito funcional disponibilizado nesta arquitetura e o objetivo é permitir o envio de notificação ao usuário via \textit{push} ou local (partindo do próprio aplicativo). As notificações via \textit{push} é suportado apenas no Android e iOS e as notificações locais podem ser enviadas nos dispositivos móveis, linux desktop e MacOS. As notificações podem ser utilizadas para alertar o usuário de algum evento na aplicação e pode conter um título, uma descrição e nas plataformas mobile, pode vibrar o dispositivo e emitir um som. Outro recurso disponibilizado nas notificações é a possibilidade de adicionar algum dado extra em cada notificação. Esse dado deve ser um objeto no estilo \textit{chave.valor}. As notificações locais serão enviadas pela própria aplicação via \textit{procedure call} e as notificações via \textit{push} através do \textit{Firebase}. As subseções a seguir, descrevem detalhes de cada tipo de notificação.

\subsubsection{Notificações PUSH}
O suporte a notificações via \textit{push} já está configurado na arquitetura e o que o desenvolvedor deve fazer para enviar mensagens via \textit{push} é criar um projeto no \textit{Firebase}, exportar o arquivo \textit{google-services.json} e adicioná-lo no diretório \textit{android} e o arquivo \textit{google-services.xml} correspondente ao iOS no diretório \textit{ios}, substituindo os arquivos existentes, ambos criados como exemplo. É importante destacar que o \textit{package name} do aplicativo adicionado no \textit{AndroidManifest.xml} e o \textit{CFBundleIdentifier} no \textit{Info.plist} do iOS, devem ser o mesmo utilizado ao criar o projeto no \textit{Firebase}. Caso contrário, ocorrerá um erro ao construir o APK ou IPA, pois as bibliotecas correspondentes ao serviço de \textit{push} (adicionadas ao projeto durante o \textit{build}) farão um \textit{parsing} dos arquivos e abortará a compilação caso ocorra algum erro. No android, o \textit{package name} deve ser adicionado manualmente no arquivo \textit{build.gradle} presente no diretório \textit{android} na propriedade \textit{defaultConfig.applicationId}.\par

No android, o funcionamento de \textit{push notification} requer duas classes java que serão instanciadas na inicialização do aplicativo e funcionarão como dois serviços. Essas classes já estão no projeto e o desenvolvedor não precisa modificá-las. O primeiro serviço registra o dispositivo no \textit{Firebase} e retorna um token. O segundo serviço é um \textit{listener} de notificações via \textit{push} e ficará em execução mesmo que a aplicação seja fechada. Ao enviar uma notificação utilizando o console do \textit{Firebase} ou através de algum \textit{web service}, as notificações serão recebidas nesse serviço e enviadas para o \textit{system tray} automaticamente. Se o aplicativo estiver em execução, a notificação será encaminhada para o aplicativo em um objeto json contendo todos os dados da mensagem, tais como, o título, a data e a hora de envio e o \textit{payload} (um dado adicional não visível enviado na mensagem). Para adicionar o dado de \textit{payload}, é necessário que o \textit{web service} adicione um objeto json na requisição que é enviada ao \textit{Firebase}\footnote{https://firebase.google.com/docs/cloud-messaging/concept-options?hl=pt-br}.\par

No iOS, o arquivo \textit{QtAppDelegate.mm} presente no diretório \textit{ios} realizará o registro do dispositivo no \textit{Firebase} e contém um método que receberá as notificações via \textit{push} e re-encaminhará para a aplicação usando o mesmo evento utilizado no android. Em ambas as plataformas, o token será passado para a aplicação através do evento \textit{newPushNotificationToken} e as mensagens de push, no evento \textit{newPushNotification}. Se a aplicação estiver em execução e o usuário clicar em uma notificação colocando o aplicativo em foreground, o evento \textit{newActionNotification} será disparado passando como argumento os dados de \textit{payload} da mensagem.\par

A arquitetura dispõe do plugin de exemplo \textit{Listeners} que contém o componente \textit{PushNotificationRegister.qml}. Esse componente demonstra um exemplo de como obter o token de registro no \textit{Firebase} e enviar para o serviço \textit{REST do aplicativo}. O Exemplo 10, apresenta um objeto \textit{listener} que observa um evento na aplicação e receberá o token de registro no \textit{Firebase} quando o dispositivo for registrado no serviço.

\begin{center}
\begin{lstlisting}[language=qml,caption={Observando evento de registro do token no \textit{Firebase}},captionpos=b]
import Observer 1.0

Observer{
	id:ob
    objectName:"TokenObserver"
    event:Config.events.newPushNotificationToken
    onUpdated:{
		//enviando o token para o web service
		//eventData = o argumento do evento
		//contendo uma string com o token
		sendTokenToServer(eventData)
	}
	//adiciona o observador ao subject
	//para o evento de registro do token
	Component.onCompleted:Subject.attach(ob,event)
}
\end{lstlisting}
\end{center}

\subsubsection{Notificações Locais}
Para gerenciar as notificações locais, foi criado a classe \textit{Notification} que abstrai a plataforma e dispõe de um método para enviar uma notificação para a área de notificações do sistema em execução. Essa classe será instanciada na inicialização do aplicativo e registrada no contexto da aplicação para que os plugins possam invocar o método \textit{Notification.show}, passando o título e a mensagem da notificação e opcionalmente um objeto contendo o argumento a ser passado para a aplicação quando o usuário clicar na notificação. Quando o usuário clicar na notificação, o aplicativo ficará em \textit{foreground} (caso não esteja) e o argumento da notificação será passado para o aplicativo através do evento \textit{newActionNotification}.

O Exemplo 11, apresenta um trecho de código que demonstra como exibir uma notificação local por algum objeto de um plugin, passando um título, uma mensagem e um objeto como argumento.

\begin{center}
\begin{lstlisting}[language=qml,caption={Exibindo uma notificação local},captionpos=b]
import QtQuick 2.8

Item{
    Component.onCompleted:{
		var title = "Novo item carregado!"
		var message = "Clique para visualizar!"
		var argument = {
			key:"foo",
			value:"bar"
		}
		Notification.show(title,message,argument)
	}
}
\end{lstlisting}
\end{center}


\subsection{Comunicação Entre os Objetos e Plugins}
Esta seção descreverá o processo de comunicação entre objetos no aplicativo que está também disponível para os plugins.
A comunicação entre os objetos facilitado é um requisito funcional desta arquitetura e consiste em disponibilizar uma API de alto nível para troca de mensagens entre objetos através de eventos e consiste na implementação do padrão de projeto \textit{Observer}, com os eventos identificados por um nome. Essa API foi desenvolvida através das seguintes classes C++: \textit{Subject} e a outra \textit{Observer}. O nome do evento é uma string que identifica um evento específico e visa notificar apenas os objetos interessados, evitando o \textit{broadcast} na aplicação e consequentemente aumentando o desempenho. Nessa API, é possível enviar um argumento para o objeto observador.\par

A classe \textit{Subject} possui um atributo privado \textit{attacheds}, uma instância da classe \textit{QMap} do Qt que guardará um vetor de observadores para cada string que identifica determinado evento. Quando um objeto deseja observar um evento, ele deve primeiramente, informar o nome do evento que deseja ser notificado, e registrar-se no \textit{Subject}. Quando determinado objeto deseja notificar observadores, ele deverá invocar o método \textit{Subject.notify} passando no primeiro parâmetro uma string que identifica o evento, seguido de um objeto contendo o argumento a ser passado para os observadores.

A classe \textit{Subject} será instanciada na inicialização e registrada no contexto da aplicação identificada como \textit{"Subject"}. Os seguintes métodos são públicos e podem ser invocados pelos plugins:

\begin{itemize}
	\item \textit{attach} (void): Esse método poderá ser utilizado para adicionar observadores a uma lista de eventos na aplicação e dois parâmetros são requeridos: o primeiro é uma referência para o \textit{observer} e o segundo, é uma lista de strings contendo os eventos que o observador deseja ser notificado;

	\item \textit{detach} (void): Esse método poderá ser utilizado para remover um observador de uma lista de eventos na aplicação e dois parâmetros são requeridos: o primeiro é um ponteiro para o \textit{observer} e o segundo é a lista de eventos da qual o observador será removido;

	\item \textit{notify} (void): Esse método poderá ser utilizado por qualquer objeto da aplicação para notificar observadores de um determinado evento. Esse método requer dois parâmetros, o primeiro é uma string contendo o nome do evento, o segundo é um objeto variante contendo o dado a ser passado para o observador. Ao chamar esse método, o \textit{Subject} irá iterar o vetor de observadores correspondente ao evento solicitado, chamando para cada observador o método público \textit{update} que receberá como argumento, o nome do evento em que está sendo notificado e o argumento enviado pelo emissor.
\end{itemize}

O desenvolvedor poderá adicionar os eventos que deseja utilizar entre os plugins no arquivo de configuração, na propriedade \textit{events} e utilizá-los via acesso ao objeto \textit{Config}. Os eventos são basicamente strings e o acesso pode ser feito da seguinte forma: \textit{Config.events.event\_name}. O Exemplo 12, demonstra como utilizar o \textit{Observer} por algum plugin, realizando uma operação de inserção no banco de dados quando o objeto for notificado.

\begin{center}
\begin{lstlisting}[language=qml,caption={Criando um objeto Observer no aplicativo},captionpos=b]
import Observer 1.0
...
Observer{
	id:observer
	objectName:"obs1"
	events:[Config.events.newSourceAdded]
	onUpdated:database.insert(eventData)
}
...
Item{
	Component.onCompleted:{
		var evt = Config.events.newSourceAdded
		Subject.attach(observer,evt)
	}
}
...
\end{lstlisting}
\end{center}

O Exemplo 13 a seguir, demonstra como notificar os observadores de um determinado evento, passando como argumento do evento um objeto javascript:

\begin{center}
\begin{lstlisting}[language=qml,caption={Notificando observadores através do objeto Subject},captionpos=b]
import QtQuick 2.8
...
Item{
	id:rootItem
	Component.onCompleted:{
		var event = Config.events.newSourceAdded
		var args = {
			key:"foo",
			value:"bar"
		}
		Subject.notify(event,args)
	}
}
\end{lstlisting}
\end{center}


\subsection{O Perfil de Usuário}
A arquitetura dispõe o componente \textit{UserProfile.qml} para gerenciar os dados do usuário do aplicativo, ele será instanciado na inicialização da aplicação e setado no objeto \textit{userProfile} se houver login na aplicação, ou seja, se o desenvolvedor definir nas configurações a propriedade \textit{usesLogin} para \textit{true}. Esse objeto (\textit{userProfile}) estará disponível para os plugins como um objeto global, e a propriedade \textit{profile} poderá ser utilizada em \textit{bindings} com outros objetos. No entanto, atualizações no perfil do usuário não devem ser feitas diretamente na propriedade \textit{profile} e sim, através de eventos.\par

O componente \textit{UserProfile.qml} observará três eventos na aplicação pelo qual os plugins devem utilizá-los para setar ou editar as informações do usuário. O primeiro evento \textit{initUserProfile}, poderá ser utilizado para inicializar o perfil do usuário após o login e o argumento do evento deve conter um objeto enviado pelo serviço \textit{REST} contendo no mínimo os campos \textit{id} e \textit{email}. O segundo evento \textit{setUserProfileData}, deve ser utilizado para atualizar ou adicionar alguma informação ao perfil do usuário. Nesse evento, o argumento deve conter as propriedades \textit{key} com o nome do campo a ser atualizado (ou adicionado) e \textit{value} a informação para o campo correspondente. O terceiro evento \textit{logoutApplication}, deve ser disparado pela página de \textit{logout} para avisar que a seção foi encerrada e o usuário será direcionado para a página de login. No \textit{logout}, o argumento do evento pode ser \textit{false} ou simplesmente \textit{null}. O componente \textit{UserProfile} dispõe das seguintes propriedades:

\begin{itemize}
	\item \textit{profile} (object): Um objeto javascript que guardará os dados do perfil do usuário, no estilo \textit{campo.valor}. Os plugins podem fazer \textit{binding} com esse objeto em elementos visuais tais como, exibir a imagem de perfil através do campo \textit{image\_url} (via \textit{profile.image\_url}). Esse objeto será persistido a cada alteração;

	\item \textit{profileName} (string): Uma string contendo o nome do perfil do usuário, por exemplo, \textit{administrator}, \textit{editor}, \textit{student} etc. Essa propriedade será setada internamente quando o \textit{profile} for definido ou alterado. No entanto, o nome do perfil do usuário deve ser passado pelo serviço \textit{REST} na resposta do login. É importante destacar que essa propriedade será definida somente se o serviço \textit{REST} adicionar no json (do perfil do usuário, retornado no login) a propriedade \textit{permission} como um objeto contendo \textit{name} ou \textit{description}. A exibição das páginas para o usuário será baseado nessa propriedade através de \textit{bindings} nos menus do aplicativo. Se a propriedade \textit{roles} na configuração das páginas dos plugins for definido e \textit{profileName} for uma string vazia o usuário não visualizará as páginas no menu do aplicativo;

	\item \textit{isLoggedIn} (bool): Essa propriedade será definida para \textit{true} quando \textit{profile} for modificado contendo alguma informação válida, ou seja, \textit{id} e \textit{email} (no mínimo). \textit{isLoggedIn} será \textit{false} quando não houver informações em \textit{profile}. Essa propriedade será modificada internamente após os eventos \textit{initUserProfile} e \textit{logoutApplication}. O valor de \textit{isLoggedIn} será persistido sempre que for modificado.
\end{itemize}

O objeto \textit{userProfile} invocará uma função interna que carregará a página inicial (\textit{home page}) após \textit{profile} ser modificado, ou seja, após o evento \textit{initUserProfile}. A página de login também será carregada após o evento \textit{logoutApplication}. A arquitetura disponibiliza o plugin de exemplo \textit{Login} contendo alguns arquivos que demonstram a utilização do \textit{login}, \textit{logout}, exibição do perfil e como solicitar alterações nos dados do usuário através do evento \textit{setUserProfileData} (o arquivo ProfileEdit.qml).\par

É importante destacar, que após o sucesso do primeiro login, não será necessário logar novamente até que o usuário faça logout ou limpe o cache do aplicativo nas configurações do dispositivo. Além disso, a imagem presente em \textit{assets/default\_user\_profile.svg} será setado no perfil do usuário após o login, na propriedade \textit{image\_url} e o desenvolvedor poderá sobrescrever esse arquivo por uma imagem de sua preferência.\par

O Exemplo 14 a seguir, apresenta um trecho de código que utiliza informações do perfil do usuário através do objeto \textit{userProfile}, exibindo o email e a imagem de perfil do usuário.

\begin{center}
\begin{lstlisting}[language=qml,caption={Utilizando informações do usuário},captionpos=b]
import QtQuick 2.8
...
Column{
	spacing: 10

	//userProfile: objeto global criado e
	//declarado no main window
	property var profileData:userProfile.profile

	//exibindo a imagem de perfil
	Image{
		id:userImg
		asynchronous:true;cache:true
		source:profileData.image_url
	}

	//exibindo o email do usuario
	Label{
		id:userEmail
		text:profileData.email
	}
}
\end{lstlisting}
% \captionof{lstlisting}{Exemplo de como exibir informações do usuário}
\end{center}


\subsection{O Componente BasePage}
O componente \textit{BasePage} é um arquivo genérico que fornece algumas propriedades para as páginas dos plugins, além de fazer \textit{bindings} com o \textit{ToolBar}, o \textit{TabBar}. \textit{BasePage} deverá ser utilizada pelas páginas de plugins sempre que possível. Esse componente irá instanciar um \textit{ListView} contendo um \textit{ListModel} e um \textit{RequestHttp} para facilitar o trabalho do programador e reduzir a escrita de código pelos plugins. \textit{BasePage} pode ser visto como uma classe abstrata que possui alguns objetos agregados e métodos públicos prontos para uso pelos componentes que estenderem \textit{BasePage}. As propriedades a seguir, compõem o \textit{BasePage} e devem ser utilizadas para customizar o layout da página.

\begin{itemize}
	\item \textit{toolBarButtons} (array): uma lista de objetos contendo as propriedades de um botão \textit{ToolBarButton} a serem adicionados no \textit{ToolBar} dinamicamente, quando a página for carregada ou quando ficar visível para o usuário. Cada objeto deve conter as seguintes propriedades: \textit{iconName}, uma string contendo o nome de um ícone do \textit{Awesome Icons} e \textit{callback} uma função javascript que será invocada quando o botão for pressionado pelo usuário;

	\item \textit{toolBarState} (string): essa propriedade poderá ser utilizada para definir o estado do \textit{ToolBar} e três valores estão disponíveis. O primeiro deles é \textit{normal} que é o valor \textit{default}. O segundo valor é \textit{goBack} e quando for utilizado, permitirá ao usuário sair da página atual e retornar para a página anterior clicando em uma seta para a esquerda, essa seta será adicionada pelo \textit{ToolBar}. O último valor é \textit{search} que exibirá um campo de busca no \textit{ToolBar} permitindo ao usuário digitar um texto para pesquisar algo na \textit{view} da página ativa. No modo \textit{seach}, a propriedade \textit{searchText} também de \textit{BasePage} receberá uma cópia do texto digitado pelo usuário e o plugin deverá criar uma conexão com \textit{searchText} para realizar a busca do conteúdo solicitado pelo usuário;

	\item \textit{absPath} (string): essa propriedade deverá ser definida para que o menu declare um \textit{bind} entre o item correspondente (na lista de itens do menu, tornado-o selecionado) com a página atualmente vista pelo usuário. Para setar essa propriedade, a página poderá utilizar o \textit{path} do plugin mais o nome do arquivo, por exemplo: \textit{Config.plugins.plugin\_name} + o nome do arquivo QML correspondente a página. Outro exemplo, considerando um plugin chamado \textit{LoadMessages} e a página \textit{View.qml}, essa propriedade pode ser definida da seguinte forma: \textit{absPath: Config.plugins.loadmessages + "View.qml"};

	\item \textit{showToolBar} (bool): essa propriedade deverá ser utilizada se a página deseja ocultar o \textit{ToolBar};

	\item \textit{showTabBar} (bool): essa propriedade deverá ser utilizada quando a página precisar ocultar o menu do layout em linha, que é uma instancia do \textit{TabBar} do \textit{Quick Controls};

	\item \textit{hasNetworkRequest} (bool): essa propriedade é \textit{true} por \textit{default} e se mantida com o valor padrão, instanciará um objeto \textit{RequestHttp} quando a página for carregada. Outra propriedade de \textit{BasePage} associada a esta, é \textit{requestHttp} que receberá uma referência para o objeto e poderá ser utilizada pela página para fazer requisições HTTP. No entanto, se a página não realizará requisições HTTP, deverá setar \textit{false} nessa propriedade;

	\item \textit{hasListView} (bool): essa propriedade é \textit{true} por \textit{default} e se mantida com o valor padrão, instanciará um \textit{ListView} do \textit{Quick Controls} e passará a referência para a propriedade \textit{listView}. O \textit{ListView} já terá um \textit{ListModel} do QML que será atribuído a propriedade \textit{listViewModel} também de \textit{BasePage} e poderá ser utilizada pela página para fazer \textit{append} ou remover itens da \textit{view};

	\item \textit{isPageBusy} (bool): essa propriedade é \textit{false} por \textit{default} e fará um \textit{bind} com o status de cada requisição HTTP feita pela página quando o objeto \textit{RequestHttp} for instanciado. Logo, o \textit{bind} será criado somente se a página manter \textit{hasNetworkRequest} como \textit{true};

	\item \textit{isActivePage} (bool): essa propriedade fará um \textit{bind} com o \textit{window.currentPage} que é uma referência para a página atualmente vista pelo usuário;

	\item \textit{listViewDelegate} (Component): essa propriedade é \textit{null} por \textit{default} e deve ser definida pela página quando utilizar \textit{ListView} atribuindo ao \textit{delegate} correspondente. Se \textit{ListView} for instanciado, essa propriedade será atribuída ao \textit{delegate} do \textit{ListView};

	\item \textit{pageBackgroundColor} (Color): essa propriedade pode ser utilizada para definir uma cor de fundo personalizada para a página, pode ser tanto hexadecimal como RGBA. A cor padrão utilizada será o valor definido no arquivo de configuração na propriedade \textit{theme.pageBackgroundColor}.
\end{itemize}

É importante destacar que \textit{BasePage} \textit{extends} o componente \textit{Page} do \textit{Quick Controls} e as propriedades definidas em \textit{Page} serão herdadas, como por exemplo, \textit{title}, que deve ser definido para exibir ao usuário o título da página que ele está visualizando. Para utilizar \textit{BasePage}, basta adicionar a diretiva \textit{import "qrc:/publicComponents"} e declarar um objeto \textit{BasePage} como no exemplo a seguir:

\begin{center}
\begin{lstlisting}[language=qml,caption={Utilizando o componente \textit{BasePage} no aplicativo},captionpos=b]
import QtQuick.Controls 2.0
import "qrc:/publicComponents/" as Components

Components.BasePage{
	id:page

	//ignora o uso do ListView
	hasListView:false

	//define o path absoluto
	absPath:Config.plugins.pages + "Page1.qml"

	//exibe um titulo no ToolBar
	title:qsTr("Page 1")

	//permite sair da pagina atual
	//usando o botao voltar no ToolBar
	toolBarState:"goBack"

	//trata as respostas de um pedido http
	onRequestFinished:{
		console.log("status:",statusCode)
		console.log("response:" ,response)
	}
...
}
\end{lstlisting}
\end{center}


\subsection{Componentes Reutilizáveis}
A arquitetura dispõe de dez componentes reusáveis para os plugins, alguns são visuais e outros não. Para utilizá-los basta adicionar a diretiva \textit{import "qrc:/publicComponentes/"} e declarar um objeto QML. Os componentes disponíveis serão descritos a seguir:

\begin{itemize}
	\item \textit{AwesomeIcon.qml}: esse componente consiste utiliza um arquivo de fonte OTF contendo 720 ícones da biblioteca \textit{Awesome Icons} e poderá ser utilizado para exibir um ícone clicável nos fragmentos de uma página. As propriedades \textit{name}, \textit{size} e \textit{color} podem ser utilizadas para definir o ícone, o tamanho e a cor do ícone;

	\item \textit{BasePage.qml}: esse componente é o elemento descrito na seção anterior e pode ser utilizado pelos plugins nas páginas no aplicativo;

	\item \textit{CameraCapture.qml}: esse componente pode ser utilizado para abrir a câmera do dispositivo móvel ou a \textit{webcam} em laptops. Ao adicionar esse componente no \textit{StackVIew}, ele inicializará a câmera disponível no dispositivo e permitirá ao usuário capturar uma imagem clicando em qualquer ponto da tela ou, utilizando o botão \textit{photo} no rodapé da janela. Outros dois botões estarão disponíveis nos cantos da tela. O botão do lado esquerdo permitirá ao usuário alternar entre as câmeras frontal ou de fundo (se disponível), e o do lado direito, abre a janela para seleção de arquivos no dispositivo. Se o usuário capturar uma imagem com a câmera, a imagem capturada será salva em um diretório público do dispositivo e o evento \textit{cameraImageSaved} será disparado passando como argumento, uma string com o \textit{path} da imagem;

	\item \textit{CustomListView.qml}: esse componente \textit{extends} o \textit{ListView} do \textit{Quick Controls} e já dispõe de um \textit{ListModel} que será instanciado e definido como \textit{model} do \textit{ListView}. Também será adicionado efeitos de transição, além de um objeto \textit{ScrollIndicator} que exibirá uma barra de rolagem vertical dinamicamente;

	\item \textit{Datepicker.qml}: esse componente pode ser utilizado para exibir um caledário contendo opção de seleção de dia, mês e ano. Após o usuário selecionar uma data, o sinal \textit{dateSelected(int day, int month, int year)} será emitido pelo objeto;

	\item \textit{ListItem.qml}: esse componente é um \textit{ItemDelegate} do \textit{Quick Controls} e permite adicionar até quatro elementos visuais, além de uma borda no rodapé que será utilizada como separador em uma lista de elementos. A utilização desse componente pode ser feita tanto como \textit{delegate} de um \textit{ListView} como em uma página dentro de um \textit{ColumnLayout}. Os elementos visuais são: um ícone do \textit{Awesome Icon} através da propriedade \textit{primaryIconName} ou uma imagem setando o \textit{source} na propriedade \textit{primaryImageSource} e será posicionado no lado esquerdo e centralizado verticalmente.\par
	Ao lado direito do ícone (lateral esquerdo, se for definido), pode ser adicionado um texto e uma descrição através das propriedades \textit{primaryLabelText} e \textit{secondaryLabelText} respectivamente, um abaixo do outro, sendo a descrição com o \textit{font-size} e opacidade reduzidos. O último elemento visual, é o mesmo do primeiro só que, posicionado no lado direito e pode ser um ícone do \textit{Awesome Icon} ou uma imagem. A imagem em ambos os lados pode ser um endereço remoto ou a partir do \textit{qrc};

	\item \textit{PasswordField.qml}: esse componente \textit{extends} o \textit{TextField} do \textit{Quick Controls} e pode ser utilizado para exibir um campo de senha para o usuário, contendo um ícone do \textit{Awesome} ao lado direito centralizado verticamente. O ícone permitirá exibir a senha digitada no campo quando for clicado, alternando o valor da propriedade \textit{echoMode} entre \textit{Password} e \textit{Normal};

	\item \textit{PhotoSelection.qml}: esse componente é um \textit{Popup} do \textit{Quick Controls} e pode ser utilizado para exibir uma lista vertical de itens clicáveis para o usuário. Três opções estão disponíveis: A primeira opção, ao ser clicada, abre a câmera do dispositivo, ou seja, irá instanciar \textit{CameraCapture.qml}. A segunda opção abrirá a galeria de imagens do dispositivo para seleção de um único arquivo. A terceira opção, ao ser clicada, nada será feito internamente, apenas emitirá o sinal \textit{removeCurrentPhoto} para que algum plugin possa executar essa ação de remover a imagem de perfil do usuário;

	\item \textit{RoundedImage.qml}: esse componente exibe uma imagem circular e dispõe as propriedades \textit{imgSource} para o \textit{path} da imagem (local ou remota) e \textit{borderColor} para definir uma cor para a borda (o padrão é transparente). A imagem será adicionada em um retângulo com um \textit{MouseArea}, tornando possível capturar eventos de \textit{click} ou pressionamento na imagem;

	\item \textit{TimePicker.qml}: esse componente exibirá um relógio baseado em \textit{hora:minuto:segundos}. Ele \textit{extends} \textit{Popup} do \textit{Quick Controls} e para abrir o diálogo, é preciso chamar o método \textit{open()} a partir do objeto declarado. Quando o usuário selecionar a hora e clicar no botão \textit{OK}, o sinal \textit{timeSelected(var time)} será emitido.
\end{itemize}


\subsection{Fluxo de Execução}
A Figura exibida no final desta seção, demonstra o \textit{workflow} de um aplicativo baseado nesta arquitetura. As aplicações Qt possuem nas plataformas mobile, objetos \textit{Java} e \textit{ObjectiveC} no android e iOS respectivamente, que inicializam o aplicativo em cada plataforma e em seguida executam a aplicação tendo como ponto de entrada o \textit{main.cpp}.\par

Os elementos visuais serão carregados no \textit{main.qml} que será instanciado no último passo antes de iniciar o \textit{loop} da aplicação. O \textit{main.qml} corresponde a \textit{ApplicationWindow} do \textit{Quick Controls} e poderá ser acessado por qualquer objeto através do id \textit{window}. Os \textit{listeners} serão carregados quando \textit{window} estiver pronto e poderão acessar qualquer uma das propriedades declaradas no escopo do \textit{window}, tais como \textit{userProfile}. O \textit{window} contém dois \textit{widgets} que podem ser utilizados para exibir avisos ao usuário. Os \textit{widgets} são \textit{Snackbar}\footnote{https://material.io/guidelines/components/snackbars-toasts.html} e \textit{Toast} e foram inspirados nos respectivos componentes do \textit{Material Design}\footnote{https://material.io/guidelines}. Os \textit{widgets} dispõe da função \textit{show} que exige uma string como parâmetro, essa string será o texto exibido ao usuário.\par

A Figura 11, apresenta de uma forma resumida o fluxo de inicialização e a sequência de objetos instanciados em um aplicativo baseado nesta arquitetura.

\begin{figure}[H]
	\includegraphics[width=8cm]{diagrama_fluxo_execucao}
	\centering
	\caption{\textit{workflow} da execução de um aplicativo Qt}
\end{figure}


\subsection{Processo de Instanciação da Arquitetura}
% descrever o README do projeto no github
Para utilizar a arquitetura desenvolvida, é necessário seguir uma determinada ordem de atividades que serão descritas abaixo. O código fonte da arquitetura encontra-se em uma página do \textit{github}, no link \cite{codigo_fonte_url} e é necessário utilizar o \textit{git} para obter uma cópia e iniciar a criação de um aplicativo. É preciso configurar o ambiente de desenvolvimento Qt para android ou iOS, além de baixar o android \textit{SDK} e o \textit{NDK}. No primeiro \textit{build} do aplicativo (na versão para android), o \textit{Gradle} baixará algumas bibliotecas para a máquina do desenvolvedor requeridas para o funcionamento do \textit{push notification}. Para criar um aplicativo usando esta arquitetura basta seguir o passo-a-passo abaixo:\par

\begin{enumerate}
	\item Acessar a página do projeto no \textit{github} e criar um \textit{fork} para a conta do desenvolvedor.

	\item Em seguida, basta clonar o projeto para a computador que será utilizado. É possível também, clonar a partir da página do projeto e alterar a url de origem.

	\item Após finalizar o processo de clone via git, renomear a pasta clonada e o arquivo \textit{tcc.pro} para o nome do aplicativo a ser desenvolvido.

	\item Importar o projeto (arquivo .pro) no \textit{QtCreator} e configurar as plataformas suportadas pelo aplicativo.

	\item Abrir o arquivo \textit{config.json} presente na raíz do projeto (manualmente usando algum editor) ou pelo \textit{QtCreator} na aba Resources \textit{config.qrc/config.json} e configurar as propriedades do aplicativo como foi descrito na seção 4.10. Os valores pré-definidos foram setados apenas como exemplo.

	\item Abrir o arquivo \textit{AndroidManifest.xml} no \textit{QtCreator} e renomear o \textit{package name}, de \textit{org.qtproject.example} para o nome do pacote do aplicativo a ser desenvolvido.

	\item Para utilizar \textit{push notification}, é necessário criar um projeto do \textit{Firebase} e adicionar o suporte a \textit{push notification}\footnote{https://console.firebase.google.com/project/novo-projeto-do-firebase/notification}. Em seguida, configurar as opções do projeto do \textit{Firebase} e no final do \textit{wizard} de configuração é necessário exportar o arquivo \textit{google-services.json} e salvar na pasta \textit{android} e IOS substituindo os arquivos existentes, também criados apenas como exemplo.

	\item No android, é necessário mais um passo para habilitar o \textit{push notification}. É preciso editar o arquivo \textit{android/build.gradle} e renomear o valor da propriedade \textit{defaultConfig.applicationId} (linha 71) para o \textit{package name} do aplicativo.

	\item Para customizar as cores do aplicativo no android (\textit{Action Bar}, \textit{Status Bar} e na janela do aplicativo), basta editar o arquivo \textit{android/res/values/colors.xml}. A cor definida em \textit{colorPrimary} será utilizada como cor de fundo no ícone de notificações via \textit{push} ou local.

	\item Em seguida, adicionar os ícones do aplicativo no diretório \textit{android/res/drawable-(*)dpi} e \textit{ios/icons}. O projeto vem com ícones nos tamanhos ideais (para android). No android, é possível utilizar alguma ferramenta online\footnote{https://jgilfelt.github.io/AndroidAssetStudio/icons-launcher.html} para gerar os ícones. No iOS, é recomendável utilizar a interface do \textit{XCode} para importar os ícones, eles serão mapeados no arquivo xml \textit{Info.plist} que é equivalente ao \textit{AndroidManifest.xml}.

	\item Se algum plugin precisar exibir a logo ou o ícone do aplicativo, deve ser adicionado uma cópia de um ícone na pasta \textit{assets} que está na raiz do projeto. Os ícones da pasta \textit{android} ou \textit{ios} não serão acessíveis por objetos da aplicação e o ícone nesta pasta será utilizado em modo desktop. Neste mesmo diretório, está a imagem \textit{drawer.jpg} utilizada no menu do layout em pilha, ela será carregada se a propriedade \textit{showDrawerImage} for \textit{true} no arquivo de configuração e pode ser substituída pelo programador. A imagem \textit{default\_user\_image.svg} será utilizada no perfil do usuário e também pode ser substituída por outra que combine com o design do aplicativo.

	\item O último passo é implementar as \textit{features} do aplicativo através de plugins. É possível iniciar o desenvolvimento de um plugin a partir dos exemplos fornecidos. Os plugins não serão mapeados em arquivo qrc sendo necessário criá-los manualmente, mantendo-os em uma pasta com o nome do plugin seguido de um arquivo \textit{config.json}, além de aquivos QML e imagens. Tudo que tiver na pasta do plugin será empacotado no APK ou IPA. Não é recomendável utilizar o \textit{wizard} de adição de arquivos do \textit{QtCreator}, pois ele adicionará os arquivos em \textit{public.qrc} ou \textit{private.qrc}, que contém os componentes internos e reutilizáveis criando um acoplamento entre plugins e núcleo, violando um requisito não funcional desta arquitetura.
\end{enumerate}